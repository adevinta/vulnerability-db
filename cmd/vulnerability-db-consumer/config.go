/*
Copyright 2020 Adevinta
*/

package main

import (
	"io/ioutil"
	"os"
	"strconv"

	log "github.com/sirupsen/logrus"

	"github.com/BurntSushi/toml"
)

type config struct {
	MaxEventAge int `toml:"max_event_age"`
	Log         logConfig
	DB          dbConfig
	SQS         sqsConfig
	S3          s3Config
	SNS         snsConfig
	Report      reportConfig
	Maintenance maintenanceConfig
}

type logConfig struct {
	Level string
}

type dbConfig struct {
	Dialect string
	Host    string `toml:"host"`
	Port    string `toml:"port"`
	SSLMode string `toml:"sslmode"`
	User    string `toml:"user"`
	Pass    string `toml:"password"`
	Name    string `toml:"name"`
}

type sqsConfig struct {
	NProcessors uint8 `toml:"number_of_processors"`
	WaitTime    uint8 `toml:"wait_time"`
	Timeout     uint8
	QueueARN    string `toml:"queue_arn"`
	Endpoint    string `toml:"endpoint"`
}

type s3Config struct {
	Region    string `toml:"region"`
	Endpoint  string `toml:"endpoint"`
	PathStyle bool   `toml:"path_style"`
}

type snsConfig struct {
	TopicARN string `toml:"topic_arn"`
	Enabled  bool
	Endpoint string `toml:"endpoint"`
}

type reportConfig struct {
	URLReplace string `toml:"url_replace"`
}

type maintenanceConfig struct {
	Tasks []maintenanceTaskConfig
}

type maintenanceTaskConfig struct {
	Name    string
	Type    string
	Rate    int
	Options interface{}
}

func parseConfig(cfgFilePath string) (*config, error) {
	cfgFile, err := os.Open(cfgFilePath)
	if err != nil {
		return nil, err
	}
	defer cfgFile.Close()

	cfgData, err := ioutil.ReadAll(cfgFile)

	var conf config
	if _, err := toml.Decode(string(cfgData[:]), &conf); err != nil {
		return nil, err
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_DB_HOST"); envVar != "" {
		conf.DB.Host = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_DB_PORT"); envVar != "" {
		conf.DB.Port = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_DB_USER"); envVar != "" {
		conf.DB.User = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_DB_NAME"); envVar != "" {
		conf.DB.Name = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_SQS_QUEUE_ARN"); envVar != "" {
		conf.SQS.QueueARN = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_SNS_TOPIC_ARN"); envVar != "" {
		conf.SNS.TopicARN = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_REPORT_URL_RPLC"); envVar != "" {
		conf.Report.URLReplace = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_S3_REGION"); envVar != "" {
		conf.S3.Region = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_S3_ENDPOINT"); envVar != "" {
		conf.S3.Endpoint = envVar
	}

	if envVar := os.Getenv("VULNERABILITYDBCONSUMER_S3_PATH_STYLE"); envVar != "" {
		boolValue, _ := strconv.ParseBool(envVar)
		conf.S3.PathStyle = boolValue
	}

	return &conf, nil
}

// parseLogLevel parses a configured string log level
// and returns the correspondent logrus log level.
// If log level is invalid, default level is Info.
func parseLogLevel(logLevel string) log.Level {
	switch logLevel {
	case "panic":
		return log.PanicLevel
	case "fatal":
		return log.FatalLevel
	case "error":
		return log.ErrorLevel
	case "warn":
		return log.WarnLevel
	case "info":
		return log.InfoLevel
	case "debug":
		return log.DebugLevel
	case "trace":
		return log.TraceLevel
	default:
		return log.InfoLevel
	}
}
