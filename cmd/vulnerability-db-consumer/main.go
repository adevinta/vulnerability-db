/*
Copyright 2021 Adevinta
*/

package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"sync"

	"github.com/adevinta/vulnerability-db/pkg/maintenance"
	"github.com/adevinta/vulnerability-db/pkg/notify"
	"github.com/adevinta/vulnerability-db/pkg/processor"
	"github.com/adevinta/vulnerability-db/pkg/queue"
	"github.com/adevinta/vulnerability-db/pkg/results"
	"github.com/adevinta/vulnerability-db/pkg/store"
	log "github.com/sirupsen/logrus"
)

func main() {

	// Read config.
	cfgFilePath := flag.String("c", "./config.toml", "configuration file")
	flag.Parse()

	conf, err := parseConfig(*cfgFilePath)
	if err != nil {
		log.Fatalf("Error reading configuration: %v", err)
	}

	logger := setupLogger(*conf)

	// Build store.
	cs := conf.DB
	connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
		cs.Host, cs.Port, cs.User, cs.Pass, cs.Name, cs.SSLMode)
	db, err := store.NewDB(connStr, logger)
	if err != nil {
		log.Fatalf("Error connecting to DB: %v", err)
	}

	// Build notifier.
	snsConf := notify.SNSConfig{
		TopicArn: conf.SNS.TopicARN,
		Enabled:  conf.SNS.Enabled,
		Endpoint: conf.SNS.Endpoint,
	}
	snsNotifier, err := notify.NewSNSNotifier(snsConf, logger)
	if err != nil {
		log.Fatalf("Error creating notifier: %v", err)
	}

	// Build processor.
	resultsClient, err := results.NewClient(logger)
	if err != nil {
		log.Fatalf("Error creating results client: %v", err)
	}

	processor, err := processor.NewCheckProcessor(snsNotifier, db, resultsClient, conf.Report.URLReplace, conf.MaxEventAge, logger)
	if err != nil {
		log.Fatalf("Error creating queue processor: %v", err)
	}

	// Build consumer group.
	sqsConf := queue.SQSConfig{
		QueueArn:    conf.SQS.QueueARN,
		Timeout:     int64(conf.SQS.Timeout),
		MaxWaitTime: int64(conf.SQS.WaitTime),
		Endpoint:    conf.SQS.Endpoint,
	}
	sqsConsumerGroup, err := queue.NewSQSConsumerGroup(conf.SQS.NProcessors, sqsConf, processor, logger)
	if err != nil {
		log.Fatalf("Error creating queue consumer group: %v", err)
	}

	// Build and start maintenance scheduler.
	scheduler := maintenance.NewScheduler(logger, []maintenance.TaskSchedule{})
	for _, taskConfig := range conf.Maintenance.Tasks {
		t, err := maintenance.NewTask(taskConfig.Name, taskConfig.Type, taskConfig.Options, db)
		if err != nil {
			log.Fatalf("Error creating maintenance task %s: %v", taskConfig.Name, err)
		}
		err = scheduler.AddTask(t, taskConfig.Rate)
		if err != nil {
			log.Fatalf("Error scheduling maintenance task %s: %v", taskConfig.Name, err)
		}
	}
	scheduler.Start(context.Background())

	// Start consumer.
	var wg sync.WaitGroup
	sqsConsumerGroup.Start(context.Background(), &wg)
	log.Info("Started")
	wg.Wait()
}

func setupLogger(cfg config) *log.Logger {
	var logger = log.New()

	logger.SetFormatter(&log.JSONFormatter{})
	logger.SetOutput(os.Stdout)
	logger.SetLevel(parseLogLevel(cfg.Log.Level))

	return logger
}
