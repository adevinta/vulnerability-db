/*
Copyright 2020 Adevinta
*/

package notify

import (
	"testing"
	"unicode"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/lib/pq"

	"github.com/aws/aws-sdk-go/service/sns"
	"github.com/aws/aws-sdk-go/service/sns/snsiface"
	log "github.com/sirupsen/logrus"

	"github.com/adevinta/vulnerability-db/pkg/store"
)

type snsMock struct {
	snsiface.SNSAPI
	notification *sns.PublishInput
}

func (m *snsMock) Publish(s *sns.PublishInput) (*sns.PublishOutput, error) {
	m.notification = s
	return nil, nil
}

func TestSNSNotifier_PushFinding(t *testing.T) {
	type fields struct {
		conf   SNSConfig
		sns    *snsMock
		logger *log.Logger
	}

	tests := []struct {
		name    string
		fields  fields
		f       FindingNotification
		want    *sns.PublishInput
		wantErr bool
	}{
		{
			name: "PushesMsgsToTopic",
			fields: fields{
				sns:    &snsMock{},
				logger: log.New(),
				conf: SNSConfig{
					TopicArn: "arn:aTopic",
				},
			},
			f: FindingNotification{
				FindingExpanded: store.FindingExpanded{
					Finding: store.Finding{
						ID:               "FindingID-1",
						AffectedResource: "AffectedResource-1",
						Score:            9,
						Status:           "OPEN",
						Details:          "Details-1",
						ImpactDetails:    "ImpactDetails-1",
					},
					Issue: store.IssueLabels{
						Issue: store.Issue{
							ID:          "IssueID-1",
							Summary:     "Summary-1",
							CWEID:       1,
							Description: "Description-1",
							Recommendations: pq.StringArray{
								"Recommendation-1",
								"Recommendation-2",
							},
							ReferenceLinks: pq.StringArray{
								"ReferenceLink-1",
								"ReferenceLink-2",
							},
						},
						Labels: []string{
							"Label-1",
							"Label-2",
						},
					},
					Target: store.TargetTeams{
						Target: store.Target{
							ID:         "TargetID-1",
							Identifier: "Identifier-1",
						},
						Teams: []string{
							"Team-1",
							"Team-2",
						},
					},
					Source: store.Source{
						ID:       "SourceID-1",
						Instance: "SourceInstance-1",
						Options:  "SourceOptions-1",
						SourceFamily: store.SourceFamily{
							Name:      "SourceName-1",
							Component: "SourceComponent-1",
						},
					},
					Resources: store.Resources{
						{
							Name: "ResourceName-1",
							Attributes: []string{
								"Attr-1",
								"Attr-2",
							},
							Resources: []map[string]string{
								{
									"Attr-1": "1",
									"Attr-2": "2",
								},
							},
						},
					},
					TotalExposure:   10,
					CurrentExposure: 5,
				},
				Tag: "tag-1",
			},
			want: &sns.PublishInput{
				Message: aws.String(removeSpaces(`
				{
					"target_id": "TargetID-1",
					"target": "Identifier-1",
					"issue_id": "IssueID-1",
					"finding_id": "FindingID-1",
					"check_id": "SourceInstance-1",
					"checktype_name": "SourceComponent-1",
					"checktype_options": "SourceOptions-1",
					"tag": "tag-1",
					"time": "0001-01-01T00:00:00Z",
					"vulnerability": {
						"id": "IssueID-1",
						"summary": "Summary-1",
						"score": 9,
						"cwe_id": 1,
						"description": "Description-1"
					}
				}`)),
				TopicArn: aws.String("arn:aTopic"),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &SNSNotifier{
				conf:   tt.fields.conf,
				sns:    tt.fields.sns,
				logger: tt.fields.logger,
			}
			if err := s.PushFinding(tt.f); (err != nil) != tt.wantErr {
				t.Errorf("got error: %v but wanted: %v", err, tt.wantErr)
			}
			diff := cmp.Diff(tt.want, tt.fields.sns.notification, cmpopts.IgnoreUnexported(sns.PublishInput{}))
			if diff != "" {
				t.Errorf("SNS payload does not match with expected one. Diff:\n%s", diff)
			}
		})
	}
}

func removeSpaces(s string) string {
	rr := make([]rune, 0, len(s))
	for _, r := range s {
		if !unicode.IsSpace(r) {
			rr = append(rr, r)
		}
	}
	return string(rr)
}
