package notify

import (
	"errors"
	"fmt"
	"reflect"
	"testing"

	"github.com/lib/pq"
	log "github.com/sirupsen/logrus"

	"github.com/adevinta/vulnerability-db/pkg/store"
)

var (
	mockEventStreamClientErr = errors.New("mockEventStreamErr")
)

type event struct {
	id       string
	payload  []byte
	metadata map[string][]byte
}

func (e event) String() string {
	return fmt.Sprintf(`
	{
		"id": "%s",
		"payload": "%s",
		"metadata": "%v"
	}`, e.id, string(e.payload), e.metadata)
}

type mockEventStreamClient struct {
	EventStreamClient
	err error
	e   event
}

func (m *mockEventStreamClient) Push(id string, payload []byte, metadata map[string][]byte) error {
	if m.err != nil {
		return m.err
	}
	m.e = event{
		id,
		payload,
		metadata,
	}
	return nil
}

func (m *mockEventStreamClient) verify(want event) bool {
	return reflect.DeepEqual(m.e, want)
}

func TestKafka_PushFinding(t *testing.T) {
	type fields struct {
		logger         *log.Logger
		eventStreamCli *mockEventStreamClient
	}

	logger := log.New()

	testCases := []struct {
		name    string
		fields  fields
		f       FindingNotification
		want    event
		wantErr error
	}{
		{
			// Note: Define the whole FindingNotification struct and expected JSON payload
			// so test fails if a modification is made to the notification struct fields or
			// JSON export definition, so we are explicitly aware of a version change.
			name: "Should send notification with version",
			fields: fields{
				logger:         logger,
				eventStreamCli: &mockEventStreamClient{},
			},
			f: FindingNotification{
				FindingExpanded: store.FindingExpanded{
					Finding: store.Finding{
						ID:               "FindingID-1",
						AffectedResource: "AffectedResource-1",
						Score:            9,
						Status:           "OPEN",
						Details:          "Details-1",
						ImpactDetails:    "ImpactDetails-1",
					},
					Issue: store.IssueLabels{
						Issue: store.Issue{
							ID:          "IssueID-1",
							Summary:     "Summary-1",
							CWEID:       1,
							Description: "Description-1",
							Recommendations: pq.StringArray{
								"Recommendation-1",
								"Recommendation-2",
							},
							ReferenceLinks: pq.StringArray{
								"ReferenceLink-1",
								"ReferenceLink-2",
							},
						},
						Labels: []string{
							"Label-1",
							"Label-2",
						},
					},
					Target: store.TargetTeams{
						Target: store.Target{
							ID:         "TargetID-1",
							Identifier: "Identifier-1",
						},
						Teams: []string{
							"Team-1",
							"Team-2",
						},
					},
					Source: store.Source{
						ID:       "SourceID-1",
						Instance: "SourceInstance-1",
						Options:  "SourceOptions-1",
						SourceFamily: store.SourceFamily{
							Name:      "SourceName-1",
							Component: "SourceComponent-1",
						},
					},
					Resources: store.Resources{
						{
							Name: "ResourceName-1",
							Attributes: []string{
								"Attr-1",
								"Attr-2",
							},
							Resources: []map[string]string{
								{
									"Attr-1": "1",
									"Attr-2": "2",
								},
							},
						},
					},
					TotalExposure:   10,
					CurrentExposure: 5,
				},
				Tag: "tag-1",
			},
			want: event{
				id: "FindingID-1",
				payload: []byte(removeSpaces(`
				{
					"id": "FindingID-1",
					"affected_resource": "AffectedResource-1",
					"score": 9,
					"status": "OPEN",
					"details": "Details-1",
					"impact_details": "ImpactDetails-1",
					"issue": {
						"id": "IssueID-1",
						"summary": "Summary-1",
						"cwe_id": 1,
						"description": "Description-1",
						"recommendations": [
							"Recommendation-1",
							"Recommendation-2"
						],
						"reference_links": [
							"ReferenceLink-1",
							"ReferenceLink-2"
						],
						"labels": [
							"Label-1",
							"Label-2"
						]
					},
					"target": {
						"id": "TargetID-1",
						"identifier": "Identifier-1",
						"teams": [
							"Team-1",
							"Team-2"
						]
					},
					"source": {
						"id": "SourceID-1",
						"instance": "SourceInstance-1",
						"options": "SourceOptions-1",
						"time": "0001-01-01T00:00:00Z",
						"name": "SourceName-1",
						"component": "SourceComponent-1"
					},
					"resources": [
						{
							"name": "ResourceName-1",
							"attributes": [
								"Attr-1",
								"Attr-2"
							],
							"resources": [
								{
									"Attr-1": "1",
									"Attr-2": "2"
								}
							]
						}
					],
					"total_exposure": 10,
					"current_exposure": 5
				}
				`)),
				metadata: map[string][]byte{
					"version": []byte(version),
				},
			},
		},
		{
			name: "Should propagate eventStreamClient error",
			fields: fields{
				logger: logger,
				eventStreamCli: &mockEventStreamClient{
					err: mockEventStreamClientErr,
				},
			},
			wantErr: mockEventStreamClientErr,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			kafka := NewKafkaNotifier(tc.fields.eventStreamCli, tc.fields.logger)

			err := kafka.PushFinding(tc.f)
			if !errors.Is(err, tc.wantErr) {
				t.Fatalf("expected error: %v but got: %v", tc.wantErr, err)
			}
			if !tc.fields.eventStreamCli.verify(tc.want) {
				t.Fatalf("error verifying finding notification event.\ngot: %v\nwant: %v", tc.fields.eventStreamCli.e, tc.want)
			}
		})
	}
}
