/*
Copyright 2020 Adevinta
*/

package notify

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/sns"
	"github.com/aws/aws-sdk-go/service/sns/snsiface"
	log "github.com/sirupsen/logrus"
)

// SNSConfig holds the required SNS config information.
type SNSConfig struct {
	TopicArn string `mapstructure:"topic_arn"`
	Endpoint string `mapstructure:"endpoint"`
}

// SNSNotifier sends notifications to an SNS topic.
type SNSNotifier struct {
	conf   SNSConfig
	sns    snsiface.SNSAPI
	logger *log.Logger
}

// FindingNotification is the data that's notified when a new finding occurs.
// TODO: This struct has been moved from processor types so it's isolated in
// the SNS notifier implementation and it's easier to deprecate in the future
// in favor of Kafka implementation. This SNS implementation only exists in
// order to maintain compatibility with old integrations that expects this
// notification format.
type findingNotification struct {
	TargetID         string        `json:"target_id"`
	Target           string        `json:"target"`
	IssueID          string        `json:"issue_id"`
	FindingID        string        `json:"finding_id"`
	CheckID          string        `json:"check_id"`
	ChecktypeName    string        `json:"checktype_name"`
	CheckTypeOptions string        `json:"checktype_options"`
	Tag              string        `json:"tag"`
	Time             time.Time     `json:"time"`
	Vulnerability    vulnerability `json:"vulnerability"`
}

type vulnerability struct {
	ID          string  `json:"id"`
	Summary     string  `json:"summary"`
	Score       float64 `json:"score"`
	CWEID       uint32  `json:"cwe_id"`
	Description string  `json:"description"`
}

// NewSNSNotifier creates a new SNSNotifier with the given configuration.
func NewSNSNotifier(conf SNSConfig, logger *log.Logger) (*SNSNotifier, error) {
	sess, err := session.NewSession()
	if err != nil {
		return nil, err
	}

	qd := parseSNSARN(conf.TopicArn)

	endpoint := qd.endpoint

	if conf.Endpoint != "" {
		endpoint = conf.Endpoint
	}

	srv := sns.New(sess, aws.NewConfig().WithEndpoint(endpoint).WithRegion(qd.region))

	notifier := &SNSNotifier{
		conf:   conf,
		logger: logger,
		sns:    srv,
	}
	return notifier, nil
}

// PushFinding pushes a finding notification to the configured sns topic.
func (n *SNSNotifier) PushFinding(f FindingNotification) error {
	// TODO: Due to the new events generation from VulnDB, now
	// Finding Notifications received as input for SNS notifier
	// might be for FIXED finding events, but these do not apply
	// to former integrations tight to SNS, therefore we have to
	// ignore them from this implementation until the dependent
	// integrations are modified.
	if f.Status != "OPEN" {
		n.logger.WithFields(log.Fields{
			"notifier": "sns",
			"id":       f.ID,
		}).Debug("ignoring FIXED finding notification")
		return nil
	}

	n.logger.WithFields(log.Fields{
		"notifier": "sns",
		"id":       f.ID,
	}).Info("pushing finding notification")

	content, err := json.Marshal(toOldFmt(f))
	if err != nil {
		return err
	}
	input := &sns.PublishInput{
		Message:  aws.String(string(content)),
		TopicArn: aws.String(n.conf.TopicArn),
	}

	_, err = n.sns.Publish(input)
	if err != nil {
		return err
	}
	return nil
}

type snsData struct {
	endpoint string
	region   string
	name     string
}

func parseSNSARN(snsARN string) snsData {
	arn := strings.Split(snsARN, ":")
	region := arn[3]
	accountID := arn[4]
	name := arn[5]
	return snsData{
		name:     name,
		region:   region,
		endpoint: fmt.Sprintf("https://sns.%v.amazonaws.com/%v/%v", region, accountID, name),
	}
}

// toOldFmt translates a FindingNotification into the old
// findingNotification format.
func toOldFmt(f FindingNotification) findingNotification {
	return findingNotification{
		TargetID:         f.Target.ID,
		Target:           f.Target.Identifier,
		IssueID:          f.Issue.ID,
		FindingID:        f.ID,
		CheckID:          f.Source.Instance,
		ChecktypeName:    f.Source.Component,
		CheckTypeOptions: f.Source.Options,
		Tag:              f.Tag,
		Time:             f.Source.Time,
		Vulnerability: vulnerability{
			ID:          f.Issue.ID,
			Summary:     f.Issue.Summary,
			Score:       f.Finding.Score,
			CWEID:       f.Issue.CWEID,
			Description: f.Issue.Description,
		},
	}
}
