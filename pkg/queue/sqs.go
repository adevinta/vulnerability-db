/*
Copyright 2020 Adevinta
*/

package queue

import (
	"context"
	"fmt"
	"runtime/debug"
	"strings"
	"sync"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/sqs"
	"github.com/aws/aws-sdk-go/service/sqs/sqsiface"
	log "github.com/sirupsen/logrus"
)

const (
	maxNumberOfMsg = 10
	defSQSWaitTime = 0
)

// SQSConfig is the configuration required for an SQSConsumer.
type SQSConfig struct {
	QueueArn    string
	Timeout     int64
	MaxWaitTime int64
	Endpoint    string
}

// SQSConsumer is the SQS implementation of the QueueConsumer interface.
type SQSConsumer struct {
	config      SQSConfig
	sqsURL      string
	sqsWaitTime int64
	sqs         sqsiface.SQSAPI
	processor   Processor
	logger      *log.Logger
}

// SQSConsumerGroup is a group of SQSConsumers.
type SQSConsumerGroup struct {
	consumers []*SQSConsumer
}

type awsData struct {
	region      string
	sqsName     string
	sqsEndpoint string
}

// NewSQSConsumerGroup creates a new SQSConsumerGroup.
func NewSQSConsumerGroup(nConsumers uint8, config SQSConfig, processor Processor, logger *log.Logger) (*SQSConsumerGroup, error) {
	var consumerGroup SQSConsumerGroup

	awsSess, err := session.NewSession()
	if err != nil {
		return nil, err
	}

	awsData := parseQueueARN(config.QueueArn)

	var consumers []*SQSConsumer
	for i := uint8(0); i < nConsumers; i++ {
		c, err := newSQSConsumer(awsSess, awsData, config, processor, logger)
		if err != nil {
			return nil, err
		}

		consumers = append(consumers, c)
	}

	consumerGroup.consumers = consumers
	return &consumerGroup, nil
}

// newSQSConsumer creates a new SQSConsumer reusing an existent AWS session.
func newSQSConsumer(awsSess *session.Session, awsData awsData, config SQSConfig, processor Processor, logger *log.Logger) (*SQSConsumer, error) {
	endpoint := awsData.sqsEndpoint

	if config.Endpoint != "" {
		endpoint = config.Endpoint
	}

	sqsSvc := sqs.New(awsSess, aws.NewConfig().WithEndpoint(endpoint).WithRegion(awsData.region))
	sqsURLData, err := sqsSvc.GetQueueUrl(&sqs.GetQueueUrlInput{QueueName: aws.String(awsData.sqsName)})
	if err != nil {
		return nil, err
	}

	return &SQSConsumer{
		config:      config,
		sqsURL:      *sqsURLData.QueueUrl,
		sqsWaitTime: defSQSWaitTime,
		sqs:         sqsSvc,
		processor:   processor,
		logger:      logger,
	}, nil
}

// Start makes the consumer group start reading and processing messages from the queue.
func (g *SQSConsumerGroup) Start(ctx context.Context, wg *sync.WaitGroup) {
	for _, consumer := range g.consumers {
		wg.Add(1)
		go consumer.start(ctx, wg)
	}
}

func (c *SQSConsumer) start(ctx context.Context, wg *sync.WaitGroup) {
	defer func() {
		if err := recover(); err != nil {
			errMssg := fmt.Sprintf("Consumer stopping due to panic err: '%v'. Stack Trace: %s",
				err, string(debug.Stack()))
			c.logger.Error(errMssg)
		}

		wg.Done()
	}()

	for {
		select {
		case <-ctx.Done():
			return
		default:
			if err := c.readAndProcess(ctx); err != nil {
				c.logger.Errorf("Error reading SQS messages: %v", err)
			}
		}
	}
}

func (c *SQSConsumer) readAndProcess(ctx context.Context) error {
	mssgs, err := c.readMssgs(ctx)
	if err != nil {
		return err
	}

	// Adjust SQS wait time based on
	// number of retrieved messages
	if len(mssgs) == 0 {
		c.sqsWaitTime = c.config.MaxWaitTime
	} else {
		c.sqsWaitTime = defSQSWaitTime
	}

	for _, mssg := range mssgs {
		// Check for invalid mssg
		if mssg == nil || mssg.Body == nil {
			c.logger.Errorf("Invalid SQS message: %v", mssg)

			if err = c.deleteMessage(mssg); err != nil {
				c.logger.Errorf("Error deleting processed message: %s", err.Error())
			}
			continue
		}

		// If message is valid, process it
		if err = c.processor.ProcessMessage(*mssg.Body); err != nil {
			c.logger.Errorf("Error processing SQS message: %s", err.Error())
			continue
		}

		// Delete it
		if err = c.deleteMessage(mssg); err != nil {
			c.logger.Errorf("Error deleting processed message: %s", err.Error())
		}
	}

	return nil
}

func (c *SQSConsumer) readMssgs(ctx context.Context) ([]*sqs.Message, error) {
	receiveQuery := sqs.ReceiveMessageInput{
		QueueUrl:            aws.String(c.sqsURL),
		MaxNumberOfMessages: aws.Int64(maxNumberOfMsg),
		WaitTimeSeconds:     aws.Int64(c.sqsWaitTime),
		VisibilityTimeout:   aws.Int64(c.config.Timeout),
	}

	mssgsResp, err := c.sqs.ReceiveMessageWithContext(ctx, &receiveQuery)
	if err != nil {
		return nil, err
	}

	return mssgsResp.Messages, nil
}

func (c *SQSConsumer) deleteMessage(mssg *sqs.Message) error {
	_, err := c.sqs.DeleteMessage(&sqs.DeleteMessageInput{
		ReceiptHandle: mssg.ReceiptHandle,
		QueueUrl:      aws.String(c.sqsURL),
	})

	return err
}

func parseQueueARN(queueARN string) awsData {
	arn := strings.Split(queueARN, ":")

	region := arn[3]
	name := arn[5]
	accountID := arn[4]
	endpoint := fmt.Sprintf("https://sqs.%v.amazonaws.com/%v/%v", region, accountID, name)

	return awsData{region, name, endpoint}
}
