/*
Copyright 2023 Adevinta
*/
package s3

import (
	"bytes"
	"errors"
	"io"
	"log"
	"testing"

	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/service/s3/s3iface"
)

// MockS3Client is a mock implementation of the S3API interface
type MockS3Client struct {
	s3iface.S3API
	Resp *s3.GetObjectOutput
	Err  error
}

type mockS3Client struct {
	s3iface.S3API
	DownloadOutput *s3.GetObjectOutput
	DownloadError  error
}

func (m *mockS3Client) GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error) {
	return m.DownloadOutput, m.DownloadError
}

func newMockS3Client(object string, errString string) *mockS3Client {
	var err error
	if errString != "" {
		err = errors.New(errString)
	}
	return &mockS3Client{
		DownloadError: err,
		DownloadOutput: &s3.GetObjectOutput{
			Body: io.NopCloser(bytes.NewReader([]byte(object))),
		},
	}
}

func TestDownload(t *testing.T) {
	tests := []struct {
		name          string
		reader        *Reader
		reportURL     string
		expectError   bool
		expectedError string
	}{
		{
			name: "Invalid reportURL Scheme",
			reader: &Reader{
				l: log.Logger{},
				svc: &mockS3Client{
					DownloadOutput: &s3.GetObjectOutput{},
					DownloadError:  nil,
				},
			},
			reportURL:     "http://example.com",
			expectError:   true,
			expectedError: "failed to parse S3 URL:http://example.com error:report URL unexpected scheme",
		},
		{
			name: "Invalid reportURL",
			reader: &Reader{
				l: log.Logger{},
				svc: &mockS3Client{
					DownloadOutput: &s3.GetObjectOutput{},
					DownloadError:  nil,
				},
			},
			reportURL:     ":invalid-url:",
			expectError:   true,
			expectedError: "failed to parse S3 URL::invalid-url: error:parse \":invalid-url:\": missing protocol scheme",
		},
		{
			name: "Valid reportURL and invalid report",
			reader: &Reader{
				l:   log.Logger{},
				svc: newMockS3Client("", ""),
			},
			reportURL:     "s3://bucket-name/file-key",
			expectError:   true,
			expectedError: "unexpected end of JSON input",
		},
		{
			name: "Valid reportURL and valid report",
			reader: &Reader{
				l:   log.Logger{},
				svc: newMockS3Client("", ""),
			},
			reportURL:     "s3://bucket-name/file-key",
			expectError:   false,
			expectedError: "",
		},
		{
			name: "Valid reportURL but missing object in S3",
			reader: &Reader{
				l:   log.Logger{},
				svc: newMockS3Client("", "no such key"),
			},
			reportURL:     "s3://bucket-name/missing-file-key",
			expectError:   true,
			expectedError: "failed to download S3 file: no such key",
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := test.reader.Download(test.reportURL)
			if test.expectError {
				if err == nil {
					t.Errorf("error was expected but got none")
					return
				}

				if err.Error() != test.expectedError {
					t.Errorf("unexpected error, got: %s want: %v", err.Error(), nil)
				}
			}
		})
	}
}

func TestParseS3URL(t *testing.T) {
	tests := []struct {
		name             string
		url              string
		expectedBucket   string
		expectedKey      string
		expectParseError bool
		expectedError    string
	}{
		{
			name:             "Valid S3 URL",
			url:              "s3://bucket-name/file-key",
			expectedBucket:   "bucket-name",
			expectedKey:      "file-key",
			expectParseError: false,
		},
		{
			name:             "Invalid S3 URL",
			url:              ":invalid-url:",
			expectParseError: true,
			expectedError:    "parse \":invalid-url:\": missing protocol scheme",
		},
		{
			name:             "Invalid URL Scheme",
			url:              "http://bucket-name/file-key",
			expectParseError: true,
			expectedError:    "report URL unexpected scheme",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			bucket, key, err := parseS3URL(test.url)

			if test.expectedBucket != bucket {
				t.Errorf("bucket does not match, got: %s want: %s", bucket, test.expectedBucket)
			}
			if test.expectedKey != key {
				t.Errorf("key does not match, got: %s want: %s", key, test.expectedKey)
			}

			if test.expectParseError {
				if test.expectedError != err.Error() {
					t.Errorf("error does not match, got: %s want: %s", err.Error(), test.expectedError)
				}
				return
			}

			if !test.expectParseError && err != nil {
				t.Errorf("unexpected error, got: %s want: %v", err.Error(), nil)
			}
		})
	}
}

func TestNewReader(t *testing.T) {
	testCases := []struct {
		name          string
		cfg           Config
		expectedError bool
	}{
		{
			name:          "Default configuration",
			cfg:           Config{},
			expectedError: false,
		},
		{
			name: "Custom configuration",
			cfg: Config{
				Region:    "us-west-1",
				Endpoint:  "https://custom-endpoint.com",
				PathStyle: true,
			},
			expectedError: false,
		},
		// Add more test cases as needed
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			reader, err := NewReader(tc.cfg, log.Logger{})

			if tc.expectedError {
				if err == nil {
					t.Error("Expected an error, but got nil")
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
				if reader == nil {
					t.Error("Reader is nil")
				}
				if reader.svc == nil {
					t.Error("S3 service is nil")
				}
				// Add more assertions for other fields if necessary
			}
		})
	}
}
