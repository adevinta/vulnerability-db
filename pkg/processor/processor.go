/*
Copyright 2020 Adevinta
*/

package processor

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	report "github.com/adevinta/vulcan-report"

	"github.com/adevinta/vulnerability-db/pkg/notify"
	"github.com/adevinta/vulnerability-db/pkg/results"
	"github.com/adevinta/vulnerability-db/pkg/store"
	log "github.com/sirupsen/logrus"
)

const (
	vulcanSource   = "vulcan"
	statusFinished = "FINISHED"
)

var (
	// ErrInvalidMssgFormat indicates that the check message has an invalid format.
	ErrInvalidMssgFmt = errors.New("Invalid message format")

	// ErrInvalidReportRplcFmt indicates that the format of the configured replacing
	// URL for vulcan-results is invalid.
	ErrInvalidReportRplcFmt = errors.New("Invalid report replace string format")

	// ErrInvalidReport indicates that a report URL or data is invalid.
	ErrInvalidReport = errors.New("Invalid report data")
)

// Resources defines the shape of the resources of a vulnerability that will
// be stored in a vulndb finding.
type Resources []ResourceGroup

// ResourceGroup reprents a resource in a vulndb finding.
type ResourceGroup struct {
	Name       string              `json:"name"`
	Attributes []string            `json:"attributes"`
	Resources  []map[string]string `json:"resources"`
}

// VulnResourcesFromReportResources populates vulnd db resources from vulcan vulnerability resources.
func VulnResourcesFromReportResources(vulnresources []report.ResourcesGroup) Resources {
	var res Resources
	for _, vr := range vulnresources {
		res = append(res, ResourceGroup{
			Name:       vr.Name,
			Attributes: vr.Header,
			Resources:  vr.Rows,
		})
	}
	return res
}

// CheckProcessor is a QueueProcessor implementation
// for vulcan check messages.
type CheckProcessor struct {
	notifier           notify.Notifier
	store              store.VulnStore
	resultsClient      results.Client
	logger             *log.Logger
	maxEventAge        int
	reportURLReplace   string
	reportURLReplaceBy string
}

// NewCheckProcessor builds a new Check Processor
func NewCheckProcessor(notifier notify.Notifier, store store.VulnStore, resultsClient results.Client, reportURLReplaceConfig string, maxEventAge int, logger *log.Logger) (*CheckProcessor, error) {
	var reportURLReplace, reportURLReplaceBy string
	if reportURLReplaceConfig != "" {
		parts := strings.Split(reportURLReplaceConfig, "|")
		if len(parts) != 2 {
			return nil, ErrInvalidReportRplcFmt
		}
		reportURLReplace = parts[0]
		reportURLReplaceBy = parts[1]
		logger.Infof("report replace string %s with %s", reportURLReplace, reportURLReplaceBy)
	}
	return &CheckProcessor{
		notifier,
		store,
		resultsClient,
		logger,
		maxEventAge,
		reportURLReplace,
		reportURLReplaceBy,
	}, nil
}

// ProcessMessage processes a vulcan check message
func (p *CheckProcessor) ProcessMessage(m string) error {
	// The way events are processed assumes  it's acceptable that the data
	// regarding the status and stats of the findings related to the source in
	// the message can be inconsistent while the the message is being
	// processed.
	check, err := parseCheckMssg(m)
	if err != nil {
		return err
	}
	if check.Status != statusFinished {
		p.logger.Infof("Ignoring check %s with status '%s'",
			check.ID, check.Status)
		return nil
	}

	p.logger.Trace("Parsing report...")
	checkTime, vulns, err := p.parseCheckReport(check.Report)
	if err != nil {
		if err == ErrInvalidReport {
			// If report is invalid, return nil
			// so mssg is deleted from queue.
			err = nil
		}
		return err
	}

	p.logger.Debugf("Processing check with ID: %s", check.ID)

	p.logger.Trace("Processing target...")
	target, err := p.processTarget(check.Target, check.Tag)
	if err != nil {
		return err
	}

	p.logger.Trace("Processing vulnerabilities...")
	sourceFindings, err := p.processVulns(vulns)
	if err != nil {
		return err
	}

	p.logger.Trace("Processing source...")
	source := p.sourceFromCheck(*check, target.ID, checkTime)
	err = p.store.ProcessSourceExecution(source, sourceFindings)
	if err != nil && !store.IsDuplicateErr(err) {
		return err
	}

	p.logger.Trace("Sending open findings...")
	err = p.notifyOpenFindings(source)
	if err != nil {
		return err
	}

	p.logger.Infof("Successfully processed check with ID: %s", check.ID)
	return nil
}

// processTarget creates a new target in the vulnerability db for the given identifier
// and returns the created target if it does not exist. If target already exists returns it.
func (p *CheckProcessor) processTarget(identifier, tag string) (*store.Target, error) {
	target := store.Target{
		Identifier: identifier,
	}

	return p.store.CreateTargetIfNotExists(target, []string{tag})
}

func (p *CheckProcessor) sourceFromCheck(c CheckMessage, targetID string, t time.Time) store.Source {
	source := store.Source{
		Instance: c.ID,
		Options:  c.Options,
		SourceFamily: store.SourceFamily{
			Name:      vulcanSource,
			Component: c.ChecktypeName,
			Target:    targetID,
		},
		Time: t,
	}
	return source
}

// parseCheckReport downloads the report data and returns the check end time and list of issues reported by it.
func (p *CheckProcessor) parseCheckReport(reportURL string) (time.Time, []report.Vulnerability, error) {
	if p.reportURLReplace != "" {
		reportURL = strings.Replace(reportURL, p.reportURLReplace, p.reportURLReplaceBy, -1)
	}

	p.logger.Tracef("Downloading report from url: %s", reportURL)
	report, err := p.resultsClient.Download(reportURL)
	if err != nil {
		if err == results.ErrInvalidURL || err == results.ErrInvalidRespStatus {
			// If error is due to invalid report URL
			// or invalid HTTP status code, discard report.
			err = ErrInvalidReport
		}
		return time.Now(), nil, err
	}

	age := int(time.Now().Sub(report.EndTime).Hours() / 24)
	if p.maxEventAge > 0 && age > p.maxEventAge {
		p.logger.Warnf("Discarding report %s due to max age exceeded", reportURL)
		return time.Now(), nil, ErrInvalidReport
	}

	return report.EndTime, report.Vulnerabilities, nil
}

// processVulns iterates for every vulnerability, for each one, it ensures a
// issue is created if it does not exists, ir returns a slice if SourceFindings
// with the corresponding issue id and the score set in the vulnerability.
func (p *CheckProcessor) processVulns(vulns []report.Vulnerability) ([]store.SourceFinding, error) {
	var created = make([]store.SourceFinding, 0)
	for _, vuln := range vulns {
		// Create issue.
		i := store.Issue{
			Summary:         vuln.Summary,
			CWEID:           vuln.CWEID,
			Description:     vuln.Description,
			Recommendations: vuln.Recommendations,
			ReferenceLinks:  vuln.References,
		}

		issue, err := p.store.CreateIssueIfNotExists(i)
		if err != nil {
			return nil, err
		}
		r := VulnResourcesFromReportResources(vuln.Resources)
		var resources *[]byte
		if len(r) > 0 {
			res, err := json.Marshal(r)
			if err != nil {
				return nil, err
			}
			resources = &res
		}

		created = append(created, store.SourceFinding{
			IssueID:       issue.ID,
			Score:         vuln.Score,
			Details:       vuln.Details,
			ImpactDetails: vuln.ImpactDetails,
			Resources:     resources,
		})
	}
	return created, nil
}

func (p *CheckProcessor) notifyOpenFindings(source store.Source) error {
	// Notify the findings found by this source that are still open. Note that
	// we assume that a finding can be notified multiple times when, for
	// instance, if checks for the same target are processed not in the same
	// order that they were executed.
	sourceF, err := p.store.GetOpenSourceFindings(source.ID)
	if err != nil {
		return err
	}
	for _, sf := range sourceF {
		issue, err := p.store.FindIssueByID(sf.IssueID)
		if err != nil {
			return err
		}
		err = p.notifier.Push(
			FindingNotification{
				TargetID:         source.Target,
				IssueID:          issue.ID,
				ChecktypeID:      source.Instance,
				ChecktypeName:    source.Component,
				CheckTypeOptions: source.Options,
				Vulnerability: vulnerability{
					ID:          issue.ID,
					Summary:     issue.Summary,
					Score:       float32(sf.Score),
					CWEID:       issue.CWEID,
					Description: issue.Description,
				}},
		)
		if err != nil {
			return err
		}
	}
	return nil
}

func parseCheckMssg(m string) (*CheckMessage, error) {
	// Message received from SQS queue is encapsulated in an
	// SNS notification first
	notif := Notification{}
	if err := json.Unmarshal([]byte(m), &notif); err != nil {
		return nil, ErrInvalidMssgFmt
	}

	// Parse notification's inner check data
	check := CheckMessage{}
	if err := json.Unmarshal([]byte(notif.Message), &check); err != nil {
		return nil, ErrInvalidMssgFmt
	}

	return &check, nil
}
