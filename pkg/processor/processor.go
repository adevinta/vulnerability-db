/*
Copyright 2020 Adevinta
*/

package processor

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	report "github.com/adevinta/vulcan-report"

	"github.com/adevinta/vulnerability-db/pkg/notify"
	"github.com/adevinta/vulnerability-db/pkg/results"
	"github.com/adevinta/vulnerability-db/pkg/store"
	log "github.com/sirupsen/logrus"
)

const (
	vulcanSource   = "vulcan"
	statusFinished = "FINISHED"
)

var (
	// ErrInvalidMssgFormat indicates that the check message has an invalid format.
	ErrInvalidMssgFmt = errors.New("Invalid message format")

	// ErrInvalidReportRplcFmt indicates that the format of the configured replacing
	// URL for vulcan-results is invalid.
	ErrInvalidReportRplcFmt = errors.New("Invalid report replace string format")

	// ErrInvalidReport indicates that a report URL or data is invalid.
	ErrInvalidReport = errors.New("Invalid report data")
)

// Resources defines the shape of the resources of a vulnerability that will
// be stored in a vulndb finding.
type Resources []ResourceGroup

// ResourceGroup reprents a resource in a vulndb finding.
type ResourceGroup struct {
	Name       string              `json:"name"`
	Attributes []string            `json:"attributes"`
	Resources  []map[string]string `json:"resources"`
}

// VulnResourcesFromReportResources populates vulnd db resources from vulcan vulnerability resources.
func VulnResourcesFromReportResources(vulnresources []report.ResourcesGroup) Resources {
	var res Resources
	for _, vr := range vulnresources {
		res = append(res, ResourceGroup{
			Name:       vr.Name,
			Attributes: vr.Header,
			Resources:  vr.Rows,
		})
	}
	return res
}

// CheckProcessor is a QueueProcessor implementation
// for vulcan check messages.
type CheckProcessor struct {
	notifier           notify.Notifier
	store              store.VulnStore
	resultsClient      results.Client
	logger             *log.Logger
	maxEventAge        int
	reportURLReplace   string
	reportURLReplaceBy string
}

// NewCheckProcessor builds a new Check Processor
func NewCheckProcessor(notifier notify.Notifier, store store.VulnStore, resultsClient results.Client, reportURLReplaceConfig string, maxEventAge int, logger *log.Logger) (*CheckProcessor, error) {
	var reportURLReplace, reportURLReplaceBy string
	if reportURLReplaceConfig != "" {
		parts := strings.Split(reportURLReplaceConfig, "|")
		if len(parts) != 2 {
			return nil, ErrInvalidReportRplcFmt
		}
		reportURLReplace = parts[0]
		reportURLReplaceBy = parts[1]
		logger.Infof("report replace string %s with %s", reportURLReplace, reportURLReplaceBy)
	}
	return &CheckProcessor{
		notifier,
		store,
		resultsClient,
		logger,
		maxEventAge,
		reportURLReplace,
		reportURLReplaceBy,
	}, nil
}

// ProcessMessage processes a vulcan check message
func (p *CheckProcessor) ProcessMessage(m string) error {
	// The way events are processed assumes  it's acceptable that the data
	// regarding the status and stats of the findings related to the source in
	// the message can be inconsistent while the the message is being
	// processed.

	check, err := parseCheckMssg(m)
	if err != nil {
		return err
	}

	l := p.logger.WithFields(log.Fields{
		"check_id": check.ID,
		"target":   check.Target,
		"tag":      check.Tag,
	})

	if check.Status != statusFinished {
		l.Warnf("Ignoring check with status %s", check.Status)
		return nil
	}

	l.WithFields(log.Fields{"report_url": check.Report}).Debug("Parsing report")
	checkTime, vulns, err := p.parseCheckReport(check.Report)
	if err != nil {
		if err == ErrInvalidReport {
			// If report is invalid, return nil
			// so mssg is deleted from queue.
			l.WithFields(
				log.Fields{"report_url": check.Report},
			).Warn("Ignoring check due to invalid report")
			err = nil
		}
		return err
	}

	l.Debug("Processing target")
	target, err := p.processTarget(check.Target)
	if err != nil {
		return err
	}

	l.Debugf("Processing %d vulnerabilities", len(vulns))
	sourceFindings, err := p.processVulns(vulns, check.Target)
	if err != nil {
		return err
	}

	source := p.sourceFromCheck(*check, target.ID, checkTime)

	l.Debugf("Processing source with %d source findings: %#v", len(sourceFindings), source)
	_, findingsState, err := p.store.ProcessSourceExecution(source, sourceFindings)
	if err != nil {
		l.Errorf("Error while processing source: %#v", err)
		if !store.IsDuplicateErr(err) {
			return err
		}
	}

	l.Debug("Sending open findings")
	err = p.notifyFindings(findingsState, check.Tag)
	if err != nil {
		return err
	}

	l.Info("Successfully processed check")
	return nil
}

// processTarget creates a new target in the vulnerability db for the given identifier
// and returns the created target if it does not exist. If target already exists returns it.
func (p *CheckProcessor) processTarget(identifier string) (*store.Target, error) {
	target := store.Target{
		Identifier: identifier,
	}

	return p.store.CreateTarget(target)
}

func (p *CheckProcessor) sourceFromCheck(c CheckMessage, targetID string, t time.Time) store.Source {
	source := store.Source{
		Instance: c.ID,
		Options:  c.Options,
		SourceFamily: store.SourceFamily{
			Name:      vulcanSource,
			Component: c.ChecktypeName,
			Target:    targetID,
		},
		Time: t,
	}
	return source
}

// parseCheckReport downloads the report data and returns the check end time and list of issues reported by it.
func (p *CheckProcessor) parseCheckReport(reportURL string) (time.Time, []report.Vulnerability, error) {
	if p.reportURLReplace != "" {
		reportURL = strings.Replace(reportURL, p.reportURLReplace, p.reportURLReplaceBy, -1)
	}

	report, err := p.resultsClient.Download(reportURL)
	if err != nil {
		if err == results.ErrInvalidURL || err == results.ErrInvalidRespStatus {
			// If error is due to invalid report URL
			// or invalid HTTP status code, discard report.
			p.logger.Warnf("Discarding report %s due to err: %s", reportURL, err)
			err = ErrInvalidReport
		}
		return time.Now(), nil, err
	}

	age := int(time.Now().Sub(report.EndTime).Hours() / 24)
	if p.maxEventAge > 0 && age > p.maxEventAge {
		p.logger.Warnf("Discarding report %s due to max age exceeded", reportURL)
		return time.Now(), nil, ErrInvalidReport
	}

	return report.EndTime, report.Vulnerabilities, nil
}

// processVulns iterates for every vulnerability, for each one, it ensures a
// issue is created if it does not exists, ir returns a slice if SourceFindings
// with the corresponding issue id and the score set in the vulnerability.
func (p *CheckProcessor) processVulns(vulns []report.Vulnerability, targetIdentifier string) ([]store.SourceFinding, error) {
	var created = make([]store.SourceFinding, 0)
	for _, vuln := range vulns {
		// Create issue.
		i := store.Issue{
			Summary:         vuln.Summary,
			CWEID:           vuln.CWEID,
			Description:     vuln.Description,
			Recommendations: vuln.Recommendations,
			ReferenceLinks:  vuln.References,
		}

		issue, err := p.store.CreateIssueIfNotExists(i)
		if err != nil {
			return nil, err
		}

		err = p.store.UpdateIssueLabels(issue.ID, vuln.Labels)
		if err != nil {
			return nil, err
		}

		r := VulnResourcesFromReportResources(vuln.Resources)
		var resources *[]byte
		if len(r) > 0 {
			res, err := json.Marshal(r)
			if err != nil {
				return nil, err
			}
			resources = &res
		}

		// Use Target Identifier as fallback value for Affected Resource
		if vuln.AffectedResource == "" {
			vuln.AffectedResource = targetIdentifier
		}

		// Use FindingDefaultFingerprint as fallback value for Fingerprint
		if vuln.Fingerprint == "" {
			vuln.Fingerprint = store.FindingDefaultFingerprint
		}

		created = append(created, store.SourceFinding{
			IssueID:                issue.ID,
			Score:                  vuln.Score,
			Details:                vuln.Details,
			ImpactDetails:          vuln.ImpactDetails,
			AffectedResource:       vuln.AffectedResource,
			AffectedResourceString: vuln.AffectedResourceString,
			Fingerprint:            vuln.Fingerprint,
			Resources:              resources,
		})
	}
	return created, nil
}

func (p *CheckProcessor) notifyFindings(findingsState []store.FindingState, tag string) error {
	if len(findingsState) == 0 {
		return nil
	}

	// Retrieve expanded findings for findings which state
	// has been updated due to current source execution
	var fIDs []string
	for _, fs := range findingsState {
		fIDs = append(fIDs, fs.ID)
	}
	findings, err := p.store.GetFindingsExpanded(fIDs)
	if err != nil {
		return err
	}

	p.logger.WithFields(log.Fields{
		"target": findings[0].Target.Identifier,
		"tag":    tag,
	}).Debugf("sending %d finding notifications", len(findings))

	// Notify finding state update
	for _, f := range findings {
		err = p.notifier.PushFinding(notify.FindingNotification{
			FindingExpanded: f,
			Tag:             tag,
		})
		if err != nil {
			return err
		}
	}
	return nil
}

func parseCheckMssg(m string) (*CheckMessage, error) {
	// Message received from SQS queue is encapsulated in an
	// SNS notification first
	notif := Notification{}
	if err := json.Unmarshal([]byte(m), &notif); err != nil {
		return nil, ErrInvalidMssgFmt
	}

	// Parse notification's inner check data
	check := CheckMessage{}
	if err := json.Unmarshal([]byte(notif.Message), &check); err != nil {
		return nil, ErrInvalidMssgFmt
	}

	return &check, nil
}
