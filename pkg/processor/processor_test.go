/*
Copyright 2020 Adevinta
*/

package processor

import (
	"errors"
	"reflect"
	"testing"
	"time"

	report "github.com/adevinta/vulcan-report"
	"github.com/adevinta/vulnerability-db/pkg/notify"
	"github.com/adevinta/vulnerability-db/pkg/results"
	"github.com/adevinta/vulnerability-db/pkg/store"
	log "github.com/sirupsen/logrus"
)

const (
	// Mock for an SQS check mssg.
	mockCheckMssg = "{\n  \"Type\" : \"Notification\",\n  \"MessageId\" : \"cb25c8ff-c0fa-5262-b2e2-9d545759f19c\",\n  \"TopicArn\" : \"arn:aws:sns:eu-west-1:123456789012:VulcanCore\",\n  \"Subject\" : \"Check\",\n  \"Message\" : \"{\\\"id\\\":\\\"984e49ee-53b7-4b81-ad5c-d7a9e5394083\\\",\\\"agent_id\\\":\\\"8861ef14-2048-4c9a-bb3e-ae4a8bd1dc42\\\",\\\"checktype_id\\\":\\\"b5707bbd-78d0-494e-b1b6-45bfb2ef6b49\\\",\\\"status\\\":\\\"FAILED\\\",\\\"target\\\":\\\"localhost\\\",\\\"options\\\":\\\"{\\\\\\\"sleep_time\\\\\\\":90}\\\",\\\"webhook\\\":null,\\\"score\\\":0.0,\\\"progress\\\":1.0,\\\"raw\\\":\\\"https://vulcan-results.com/v1/logs/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.log\\\",\\\"report\\\":\\\"https://vulcan-results.com/v1/reports/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.json\\\",\\\"deleted_at\\\":null,\\\"created_at\\\":\\\"2019-07-19T10:03:09.205Z\\\",\\\"updated_at\\\":\\\"2019-07-19T10:03:15.069Z\\\",\\\"scan_id\\\":null,\\\"queue_name\\\":\\\"vulcanGenericQueue\\\",\\\"tag\\\":\\\"tag\\\",\\\"checktype_name\\\":\\\"vulcan-sleep-experimental\\\"}\",\n  \"Timestamp\" : \"2019-07-19T10:03:15.086Z\",\n  \"SignatureVersion\" : \"1\",\n  \"Signature\" : \"dGVzdAo\",\n  \"SigningCertURL\" : \"https://sns.eu-west-1.amazonaws.com/SimpleNotificationService-1234567890.pem\",\n  \"UnsubscribeURL\" : \"https://sns.eu-west-1.amazonaws.com/?Action=Unsubscribe&SubscriptionArn=arn:aws:sns:eu-west-1:123456789012:VulcanCore:00000000-0000-0000-0000-000000000000\",\n  \"MessageAttributes\" : {\n    \"checktype_name\" : {\"Type\":\"String\",\"Value\":\"vulcan-sleep-experimental\"},\n    \"status\" : {\"Type\":\"String\",\"Value\":\"FAILED\"}\n  }\n}"

	pqNotFoundErr = "sql: no rows in result set"
)

type mockNotifier struct {
	calls uint8
}

func (n *mockNotifier) Push(mssg interface{}) error {
	n.calls++
	return nil
}

type inMemMockNotifier struct {
	sent []FindingNotification
}

func (n *inMemMockNotifier) Push(mssg interface{}) error {
	notif, _ := mssg.(FindingNotification)
	n.sent = append(n.sent, notif)
	return nil
}

type mockStore struct {
	store.VulnStore

	wantFindFindingErr              bool                    // Specifies if FindFinding must return error.
	wantNewFinding                  bool                    // Specifies if FindFinding must return NotFoundErr.
	wantNewCreateIssueIfNotExistErr bool                    // Specifies if CreateIssueIfNotExists must return an error.
	returnFindingStatus             string                  // Specifies FindFinding returned finding's status.
	returnCreateEventStatus         string                  // Specifies the finding status after calling CreateFindingEvent.
	returnLastFindingEvent          *store.FindingEvent     // Specifies the finding event to return for GetLastFindingEvent.
	returnSourceIssues              []*store.Issue          // Specifies the list of issues returned for GetIssuesBySource.
	returnFindingsExpanded          []store.FindingExpanded // Specifies the list of Expanded Findings returned by the GetFindingsExpanded.
	createIssueIfNotExistCalls      uint8                   // RecalculateFindingStatusResult return status.
	getOpenIssuesForSource          func(id string) ([]string, error)
	findIssueByID                   func(id string) (*store.Issue, error)
}

func (s *mockStore) CreateIssueIfNotExists(i store.Issue) (*store.Issue, error) {
	if s.wantNewCreateIssueIfNotExistErr {
		return nil, errors.New("Unexpected error")
	}
	s.createIssueIfNotExistCalls++
	return &store.Issue{
		ID: "issueA",
	}, nil
}

func (s *mockStore) UpdateIssueLabels(issueID string, labels []string) error {
	return nil
}

func (s *mockStore) FindFinding(f store.Finding) (*store.Finding, error) {
	if s.wantFindFindingErr {
		return nil, errors.New("Err")
	}

	if s.wantNewFinding {
		return nil, errors.New(pqNotFoundErr)
	}

	return &store.Finding{
		ID:     "findingA",
		Status: s.returnFindingStatus,
	}, nil
}
func (s *mockStore) CreateFinding(eventTime time.Time, f store.Finding, sourceID string) (*store.Finding, error) {
	return nil, nil
}
func (s *mockStore) CreateFindingEvent(checkTime time.Time, findingID, sourceID string, score float64, fingerprint, affectedResourceString string) (*store.Finding, error) {
	return &store.Finding{
		Status: s.returnCreateEventStatus,
	}, nil
}

func (s *mockStore) GetLastFindingEvent(findingID string) (*store.FindingEvent, error) {
	return s.returnLastFindingEvent, nil
}

func (s *mockStore) GetIssuesBySource(sourceID string) ([]*store.Issue, error) {
	return s.returnSourceIssues, nil
}

func (s *mockStore) GetOpenIssuesForSource(id string) ([]string, error) {
	return s.getOpenIssuesForSource(id)
}

func (s *mockStore) FindIssueByID(id string) (*store.Issue, error) {
	return s.findIssueByID(id)
}

func (s *mockStore) GetFindingsExpanded(id []string) ([]store.FindingExpanded, error) {
	return s.returnFindingsExpanded, nil
}

type mockResClient struct {
	results.Client
	retErr    error
	retReport report.Report
}

func (c mockResClient) Download(reportURL string) (report.Report, error) {
	return c.retReport, c.retErr
}

// processor test fields
type fields struct {
	notifier    notify.Notifier
	store       *mockStore
	resClient   mockResClient
	logger      *log.Logger
	maxEventAge int
}

func TestProcess(t *testing.T) {
	type input struct {
		vulns []report.Vulnerability
	}

	logger := log.New()

	tests := []struct {
		name                          string
		fields                        fields
		input                         input
		expectedCreateIssueIfNotExist uint8
		expectedErr                   bool
	}{
		{
			name: "Should return  err",
			fields: fields{
				notifier: &mockNotifier{},
				store: &mockStore{
					wantNewCreateIssueIfNotExistErr: true,
				},
				resClient: mockResClient{},
				logger:    logger,
			},
			input: input{
				vulns: []report.Vulnerability{
					{
						Summary: "Vulnerability 1",
					},
				}},
			expectedErr: true,
		},
		{
			name: "Should create the new issues",
			fields: fields{
				notifier:  &mockNotifier{},
				store:     &mockStore{},
				resClient: mockResClient{},
				logger:    logger,
			},
			expectedErr:                   false,
			expectedCreateIssueIfNotExist: 2,
			input: input{
				vulns: []report.Vulnerability{
					{
						Summary: "Vulnerability 1",
					},
					{
						Summary: "Vulnerability 2",
					},
				}},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			processor := &CheckProcessor{
				notifier:      tt.fields.notifier,
				store:         tt.fields.store,
				resultsClient: tt.fields.resClient,
				logger:        tt.fields.logger,
			}

			_, err := processor.processVulns(tt.input.vulns, "some-identifier")
			if err != nil && !tt.expectedErr {
				t.Fatalf("No error expected, but got: %v", err)
			}

			if tt.expectedCreateIssueIfNotExist != tt.fields.store.createIssueIfNotExistCalls {
				t.Fatalf("Create issue calls got different than expected, got %d, expected %d", tt.fields.store.createIssueIfNotExistCalls, tt.expectedCreateIssueIfNotExist)
			}
		})
	}
}

func TestNotifyOpenFindings(t *testing.T) {
	type input struct {
		findingsState []store.FindingState
		tag           string
	}

	logger := log.New()
	tests := []struct {
		name           string
		fields         fields
		input          input
		expectedNotifs []FindingNotification
	}{
		{
			name: "Should send notificatons adding check tag",
			fields: fields{
				logger:   logger,
				notifier: &inMemMockNotifier{},
				store: &mockStore{
					returnFindingsExpanded: []store.FindingExpanded{
						{Finding: store.Finding{ID: "1"}},
						{Finding: store.Finding{ID: "2"}},
					},
				},
			},
			input: input{
				findingsState: []store.FindingState{
					{ID: "1"},
					{ID: "2"},
				},
				tag: "test-tag",
			},
			expectedNotifs: []FindingNotification{
				{
					FindingExpanded: store.FindingExpanded{
						Finding: store.Finding{ID: "1"},
					},
					Tag: "test-tag",
				},
				{
					FindingExpanded: store.FindingExpanded{
						Finding: store.Finding{ID: "2"},
					},
					Tag: "test-tag",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			processor := &CheckProcessor{
				notifier:      tt.fields.notifier,
				store:         tt.fields.store,
				resultsClient: tt.fields.resClient,
				logger:        tt.fields.logger,
			}

			err := processor.notifyFindings(tt.input.findingsState, tt.input.tag)
			if err != nil {
				t.Fatalf("expected no error but got: %v", err)
			}
			got := tt.fields.notifier.(*inMemMockNotifier).sent
			if !reflect.DeepEqual(tt.expectedNotifs, got) {
				t.Errorf("expected:\n%v\nbut got:\n%v", got, tt.expectedNotifs)
			}
		})
	}
}

func TestParseCheckMssg(t *testing.T) {
	// given
	expectedCheckMssg := &CheckMessage{
		ID:            "984e49ee-53b7-4b81-ad5c-d7a9e5394083",
		AgentID:       "8861ef14-2048-4c9a-bb3e-ae4a8bd1dc42",
		ChecktypeID:   "b5707bbd-78d0-494e-b1b6-45bfb2ef6b49",
		ChecktypeName: "vulcan-sleep-experimental",
		Status:        "FAILED",
		Target:        "localhost",
		Options:       "{\"sleep_time\":90}",
		Webhook:       "",
		Score:         0.0,
		Progress:      1.0,
		Raw:           "https://vulcan-results.com/v1/logs/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.log",
		Report:        "https://vulcan-results.com/v1/reports/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.json",
		DeletedAt:     "",
		CreatedAt:     "2019-07-19T10:03:09.205Z",
		UpdatedAt:     "2019-07-19T10:03:15.069Z",
		ScanID:        "",
		QueueName:     "vulcanGenericQueue",
		Tag:           "tag",
	}

	// when
	checkMssg, err := parseCheckMssg(mockCheckMssg)
	if err != nil {
		t.Fatalf("Error parsing check mssg: %v", err)
	}

	// then
	if !reflect.DeepEqual(checkMssg, expectedCheckMssg) {
		t.Errorf("Error, expected:\n%v\nGot:\n%v", expectedCheckMssg, checkMssg)
	}
}

func TestParseCheckReport(t *testing.T) {
	logger := log.New()
	nowTime := time.Now()
	pastTime := nowTime.AddDate(0, 0, -2)
	mockErr := errors.New("MockErr")

	testCases := []struct {
		name          string
		fields        fields
		reportURL     string
		expectedTime  time.Time
		expectedVulns []report.Vulnerability
		expectedErr   error
	}{
		{
			name: "Happy path",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   nil,
		},
		{
			name: "Should return invalid report due to invalid URL",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: results.ErrInvalidURL,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   ErrInvalidReport,
		},
		{
			name: "Should return invalid report due to invalid resp status",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: results.ErrInvalidRespStatus,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   ErrInvalidReport,
		},
		{
			name: "Should return error",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: mockErr,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   mockErr,
		},
		{
			name: "Should return invalid report due to max age exceeded",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: pastTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: nil,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   ErrInvalidReport,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			processor := &CheckProcessor{
				notifier:      tc.fields.notifier,
				store:         tc.fields.store,
				resultsClient: tc.fields.resClient,
				logger:        tc.fields.logger,
				maxEventAge:   tc.fields.maxEventAge,
			}

			checkTime, vulns, err := processor.parseCheckReport(tc.reportURL)
			if err != tc.expectedErr {
				t.Fatalf("Expected error to be %v, but got %v",
					tc.expectedErr, err)
			}
			if err == nil {
				// If parsing was correct, verify expected data.
				if checkTime != tc.expectedTime {
					t.Fatalf("Expected check time to be %s, but got %s",
						tc.expectedTime.String(), checkTime.String())
				}
				if !reflect.DeepEqual(vulns, tc.expectedVulns) {
					t.Fatalf("Expected vulns to be:\n%v\nBut got:\n%v",
						tc.expectedVulns, vulns)
				}
			}
		})
	}

}

func errToStr(err error) string {
	if err == nil {
		return ""
	}
	return err.Error()
}
