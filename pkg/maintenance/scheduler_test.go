/*
Copyright 2020 Adevinta
*/

package maintenance

import (
	"context"
	"errors"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/sirupsen/logrus/hooks/test"
)

// mockOkTask.
type mockOkTask struct{}

func (t *mockOkTask) Name() string {
	return "MyMockOkTask"
}
func (t *mockOkTask) Type() string {
	return "MockOkTask"
}
func (t *mockOkTask) Execute() (TaskResult, error) {
	return TaskResult("OK"), nil
}

// mockKoTask.
type mockKoTask struct{}

func (t *mockKoTask) Name() string {
	return "MyMockKoTask"
}
func (t *mockKoTask) Type() string {
	return "MockKoTask"
}
func (t *mockKoTask) Execute() (TaskResult, error) {
	return "", errors.New("KO")
}

// mockWriterTask is a mock
// task which writes OK into a slice
// every time it gets executed.
type mockWriterTask struct {
	queue []string
	i     int
}

func (t *mockWriterTask) Name() string {
	return "MyMockWriterTask"
}
func (t *mockWriterTask) Type() string {
	return "MockWriterTask"
}
func (t *mockWriterTask) Execute() (TaskResult, error) {
	t.queue[t.i] = "OK"
	t.i++
	return "OK", nil
}

func TestAddTask(t *testing.T) {

	testCases := []struct {
		name        string
		tasks       []Task
		rates       []int
		expectedErr error
	}{
		{
			name: "happy path",
			tasks: []Task{
				&mockOkTask{},
			},
			rates: []int{
				2,
			},
			expectedErr: nil,
		},
		{
			name: "invalid rate 0",
			tasks: []Task{
				&mockOkTask{},
			},
			rates: []int{
				0,
			},
			expectedErr: ErrInvalidRate,
		},
		{
			name: "invalid rate <0",
			tasks: []Task{
				&mockOkTask{},
			},
			rates: []int{
				-1,
			},
			expectedErr: ErrInvalidRate,
		},
	}

	scheduler := NewScheduler(nil, []TaskSchedule{})

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			for i, task := range tc.tasks {
				err := scheduler.AddTask(task, tc.rates[i])
				if err != tc.expectedErr {
					if tc.expectedErr != nil {
						t.Fatalf("Expected error %v, but got: %v", tc.expectedErr, err)
					} else {
						t.Fatalf("Expected no error, but got: %v", err)
					}
				}
			}
		})
	}
}

func TestStart(t *testing.T) {
	// Slice to use as input for writer tasks
	// so they can write on it and we can use it
	// in our test to verify correct task execution.
	queue := make([]string, 5)

	testCases := []struct {
		name       string
		tasks      []TaskSchedule
		expected   string
		msToCancel int // number of ms to wait before stopping scheduler.
	}{
		{
			name: "one task happy path",
			tasks: []TaskSchedule{
				TaskSchedule{
					task: &mockWriterTask{
						queue: queue,
					},
					rate: 200,
				},
			},
			expected:   "OK",
			msToCancel: 300,
		},
		{
			name: "one KO task",
			tasks: []TaskSchedule{
				TaskSchedule{
					task: &mockKoTask{},
					rate: 200,
				},
			},
			expected:   "",
			msToCancel: 300,
		},
		{
			name: "one OK task one KO task",
			tasks: []TaskSchedule{
				TaskSchedule{
					task: &mockWriterTask{
						queue: queue,
					},
					rate: 200,
				},
				TaskSchedule{
					task: &mockKoTask{},
					rate: 200,
				},
			},
			expected:   "OK",
			msToCancel: 300,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// given
			log, _ := test.NewNullLogger()
			scheduler := &Scheduler{
				log:       log,
				tasks:     tc.tasks,
				rateUnits: time.Millisecond, // set for test.
			}

			var cancel context.CancelFunc
			ctx := context.Background()
			ctx, cancel = context.WithCancel(ctx)

			// when
			var wg sync.WaitGroup
			wg.Add(1)
			go func(wg *sync.WaitGroup, cancel context.CancelFunc, to time.Duration) {
				<-time.After(to)
				cancel()
				wg.Done()
			}(&wg, cancel, time.Duration(tc.msToCancel)*time.Millisecond)

			scheduler.Start(ctx)

			wg.Wait()

			// then
			var str strings.Builder
			for i, mssg := range queue {
				str.WriteString(mssg)
				queue[i] = "" // reset queue
			}

			if tc.expected != str.String() {
				t.Fatalf("Expected '%s', but got: '%s'", tc.expected, str.String())
			}
		})
	}
}
