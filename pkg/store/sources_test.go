/*
Copyright 2020 Adevinta
*/

package store

import (
	"context"
	"database/sql/driver"
	"reflect"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jmoiron/sqlx"
)

var (
	tTime   = time.Now()
	tSource = Source{
		ID:       "id_source_1",
		Instance: "id_check_1",
		SourceFamily: SourceFamily{
			Name:      "family_1",
			Component: "vulcan",
			Target:    "api.example.com",
		},
		Time: tTime,
	}
	createSourceQueryArgs = []driver.Value{
		tSource.Name,
		tSource.Component,
		tSource.Instance,
		tSource.Options,
		tSource.Time,
		tSource.Target,
	}
)

func TestCreateSource(t *testing.T) {
	tests := []struct {
		name               string
		insertRowsResponse *sqlmock.Rows
		selectRowsResponse *sqlmock.Rows
		expectErr          bool
		inputSource        *Source
		expectedSource     *Source
	}{
		{
			name: "CreateNonExistingSource",
			insertRowsResponse: sqlmock.NewRows(
				[]string{"id", "name", "component", "instance", "options", "time", "target_id"},
			).AddRow(
				"id_source_1", "family_1", "vulcan", "id_check_1", "", tTime, "api.example.com",
			),
			expectErr:      false,
			inputSource:    &tSource,
			expectedSource: &tSource,
		},
		{
			name:               "CreateExistingSource",
			insertRowsResponse: sqlmock.NewRows([]string{}),
			selectRowsResponse: sqlmock.NewRows(
				[]string{"id", "name", "componet", "instance", "options", "time", "target_id"},
			).AddRow(
				tSource.ID, tSource.Name, tSource.Component, tSource.Instance, tSource.Options, tSource.Time, tSource.Target,
			),
			expectErr:      false,
			inputSource:    &tSource,
			expectedSource: &tSource,
		},
		{
			name:               "CreateMalformedNonExistingSource",
			insertRowsResponse: sqlmock.NewRows([]string{}),
			expectErr:          true,
			inputSource:        &Source{},
			expectedSource:     nil,
		},
		{
			name:               "CreateMalformedExistingSource",
			insertRowsResponse: sqlmock.NewRows([]string{}),
			selectRowsResponse: sqlmock.NewRows([]string{}),
			expectErr:          true,
			inputSource:        &tSource,
			expectedSource:     nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockDB, mock, _ := sqlmock.New()
			defer mockDB.Close()
			sqlxDB := sqlx.NewDb(mockDB, "sqlmock")

			mock.ExpectBegin()
			mock.ExpectQuery("INSERT INTO").
				WithArgs(createSourceQueryArgs...).
				WillReturnRows(tt.insertRowsResponse)

			if tt.selectRowsResponse != nil {
				mock.ExpectQuery("^SELECT (.+) FROM sources").
					WithArgs(createSourceQueryArgs...).
					WillReturnRows(tt.selectRowsResponse)
			}
			ctx := context.Background()
			tx, _ := sqlxDB.BeginTxx(ctx, nil)
			screated, err := createSource(ctx, tx, *tt.inputSource)
			if tt.expectErr && err == nil {
				t.Errorf("an error was expected creating source: %s in test: %s", err, tt.name)
			}
			if !tt.expectErr && err != nil {
				t.Errorf("unexpected error creating source: %s", err)
			}
			if tt.expectErr && err != nil {
				return
			}
			if !reflect.DeepEqual(*screated, *tt.expectedSource) {
				t.Errorf("expected source: %#v does not match created source: %#v", tt.expectedSource, screated)
			}
		})
	}
}

func TestSortSourceFamilies(t *testing.T) {
	tests := []struct {
		name           string
		sourceFamilies SourceFamilies
		sortedFamilies SourceFamilies
	}{
		{
			name: "Single family",
			sourceFamilies: SourceFamilies{
				SourceFamily{
					Name:      "Name",
					Component: "Component",
					Target:    "Target",
				},
			},
			sortedFamilies: SourceFamilies{
				SourceFamily{
					Name:      "Name",
					Component: "Component",
					Target:    "Target",
				},
			},
		},
		{
			name: "Two unordered families",
			sourceFamilies: SourceFamilies{
				SourceFamily{
					Name:      "Name",
					Component: "Component",
					Target:    "Target",
				},
				SourceFamily{
					Name:      "AFamily",
					Component: "Component",
					Target:    "Target",
				},
			},
			sortedFamilies: SourceFamilies{
				SourceFamily{
					Name:      "AFamily",
					Component: "Component",
					Target:    "Target",
				},
				SourceFamily{
					Name:      "Name",
					Component: "Component",
					Target:    "Target",
				},
			},
		},
		{
			name: "Three unordered mixed families",
			sourceFamilies: SourceFamilies{
				SourceFamily{
					Name:      "Name",
					Component: "Component2",
					Target:    "Target",
				},
				SourceFamily{
					Name:      "AFamily",
					Component: "Component",
					Target:    "Target",
				},
				SourceFamily{
					Name:      "Name",
					Component: "Component",
					Target:    "Target",
				},
			},
			sortedFamilies: SourceFamilies{
				SourceFamily{
					Name:      "AFamily",
					Component: "Component",
					Target:    "Target",
				},
				SourceFamily{
					Name:      "Name",
					Component: "Component",
					Target:    "Target",
				},
				SourceFamily{
					Name:      "Name",
					Component: "Component2",
					Target:    "Target",
				},
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			tc.sourceFamilies.Sort()
			if !reflect.DeepEqual(tc.sourceFamilies, tc.sortedFamilies) {
				t.Fatalf("Error sorting source families. Expected\n%v\nBut got:\n%v",
					tc.sourceFamilies, tc.sortedFamilies)
			}
		})
	}
}
