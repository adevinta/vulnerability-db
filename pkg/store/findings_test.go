/*
Copyright 2020 Adevinta
*/

package store

import (
	"strings"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
)

var (
	stringsSliceComparer = cmpopts.SortSlices(func(a, b interface{}) bool {
		s1 := a.(string)
		s2 := b.(string)
		return strings.Compare(s1, s2) < 0
	})

	findingStateComparer = cmpopts.SortSlices(func(a, b interface{}) bool {
		if _, ok := a.(FindingExposure); ok {
			return compareFindingExposures(a, b)
		}
		e1 := a.(findingState)
		e2 := b.(findingState)
		c1 := strings.Compare(e1.ID, e2.ID)
		if c1 != 0 {
			return c1 < 0
		}
		return e1.Score < e2.Score
	})
)

func compareFindingExposures(a, b interface{}) bool {
	e1 := a.(FindingExposure)
	e2 := b.(FindingExposure)
	c1 := strings.Compare(e1.FindingID, e2.FindingID)
	if c1 != 0 {
		return c1 < 0
	}
	return e1.FoundAT.Before(e2.FoundAT)
}

func Test_buildFindingExposures(t *testing.T) {
	tests := []struct {
		name              string
		sourceF           []sourceFindings
		wantIDs           []string
		wantFindingStates []findingState
	}{
		{
			name: "BuildsProperFindingExposuresWithMultiplePeriods",
			sourceF: []sourceFindings{
				sourceFindings{
					FindingID:  strToPtr("finding1"),
					SourceID:   "source1",
					SourceTime: mustParseTime("2019-04-10 20:40:56"),
					Score:      intToFloatPtr(1),
				},
				sourceFindings{
					FindingID:  strToPtr("finding1"),
					SourceID:   "source2",
					SourceTime: mustParseTime("2019-04-15 22:58:21"),
					Score:      intToFloatPtr(2),
				},
				sourceFindings{
					FindingID:  strToPtr("finding1"),
					SourceID:   "source3",
					SourceTime: mustParseTime("2019-05-08 23:46:36"),
					Score:      intToFloatPtr(3),
				},

				sourceFindings{
					FindingID:  strToPtr("finding2"),
					SourceID:   "source4",
					SourceTime: mustParseTime("2019-04-20 00:00:00"),
					Score:      intToFloatPtr(1),
				},

				sourceFindings{
					FindingID:  strToPtr("finding3"),
					SourceID:   "source5",
					SourceTime: mustParseTime("2019-06-08 20:47:08"),
					Score:      intToFloatPtr(1),
				},
			},

			wantFindingStates: []findingState{
				findingState{
					ID:     "finding1",
					Status: "FIXED",
					Score:  3,
					Exposure: []FindingExposure{
						FindingExposure{
							FindingID: "finding1",
							FoundAT:   mustParseTime("2019-04-10 20:40:56"),
							FixedAT:   timeToPtr(mustParseTime("2019-04-20 00:00:00")),
							TTR:       intToPtr(219),
						},
						FindingExposure{
							FindingID: "finding1",
							FoundAT:   mustParseTime("2019-05-08 23:46:36"),
							FixedAT:   timeToPtr(mustParseTime("2019-06-08 20:47:08")),
							TTR:       intToPtr(741),
						},
					},
				},
				findingState{
					ID:     "finding2",
					Status: "FIXED",
					Score:  1,
					Exposure: []FindingExposure{
						FindingExposure{
							FindingID: "finding2",
							FoundAT:   mustParseTime("2019-04-20 00:00:00"),
							FixedAT:   timeToPtr(mustParseTime("2019-05-08 23:46:36")),
							TTR:       intToPtr(455),
						},
					}},
				findingState{
					ID:     "finding3",
					Status: "OPEN",
					Score:  1,
					Exposure: []FindingExposure{
						FindingExposure{
							FindingID: "finding3",
							FoundAT:   mustParseTime("2019-06-08 20:47:08"),
						},
					},
				},
			},
		},

		{
			name: "BuildsProperFindingExposuresProperScoreAnsStatus",
			sourceF: []sourceFindings{
				sourceFindings{
					FindingID:  strToPtr("finding1"),
					SourceID:   "source1",
					SourceTime: mustParseTime("2019-04-10 20:40:56"),
					Score:      intToFloatPtr(2),
				},
				sourceFindings{
					FindingID:  strToPtr("finding1"),
					SourceID:   "source2",
					SourceTime: mustParseTime("2019-04-15 22:58:21"),
					Score:      intToFloatPtr(2),
				},
				sourceFindings{
					FindingID:  strToPtr("finding1"),
					SourceID:   "source3",
					SourceTime: mustParseTime("2019-05-08 23:46:36"),
					Score:      intToFloatPtr(3),
				},

				sourceFindings{
					FindingID:  strToPtr("finding1"),
					SourceID:   "source5",
					SourceTime: mustParseTime("2019-06-08 20:47:08"),
					Score:      intToFloatPtr(1),
				},
			},

			wantFindingStates: []findingState{
				findingState{
					ID:     "finding1",
					Status: "OPEN",
					Score:  1,
					Exposure: []FindingExposure{
						FindingExposure{
							FindingID: "finding1",
							FoundAT:   mustParseTime("2019-04-10 20:40:56"),
						},
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotStates := buildFindingStates(tt.sourceF)
			diff := cmp.Diff(gotStates, tt.wantFindingStates, findingStateComparer)
			if diff != "" {
				t.Errorf("got exposures != wantExposures, diff %s", diff)
			}
		})
	}
}

func mustParseTime(t string) time.Time {
	r, err := time.Parse("2006-01-02 15:04:05", t)
	if err != nil {
		panic(err)
	}
	return r
}

func strToPtr(s string) *string {
	return &s
}

func timeToPtr(t time.Time) *time.Time {
	return &t
}

func intToPtr(i int) *int {
	return &i
}

func intToFloatPtr(i int) *float64 {
	f := float64(i)
	return &f
}
