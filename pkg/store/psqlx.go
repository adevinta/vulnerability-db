/*
Copyright 2021 Adevinta
*/

package store

import (
	"fmt"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq" // postgres driver
)

const (
	psql               = "postgres"
	errDuplicateUnique = "pq: duplicate key value violates unique constraint"
	errNotFound        = "sql: no rows in result set"
)

type psqlxStore struct {
	DB     *sqlx.DB
	logger *log.Logger
}

// NewDB builds and returns a new PSQLx implementation
// of VulnStore interface.
func NewDB(connString string, logger *log.Logger) (VulnStore, error) {
	db, err := sqlx.Connect(psql, connString)
	if err != nil {
		return nil, err
	}

	_, err = db.Exec("SET TIME ZONE 'UTC'")
	if err != nil {
		return nil, err
	}

	return &psqlxStore{
		db,
		logger,
	}, nil
}

// IsDuplicateErr determines if given error is
// a duplicate element error.
func IsDuplicateErr(err error) bool {
	return strings.HasPrefix(err.Error(), errDuplicateUnique)
}

// IsNotFoundErr determines if given error is
// a record not found error.
func IsNotFoundErr(err error) bool {
	if err == nil {
		return false
	}
	return errNotFound == err.Error()
}

func logQuery(logger *log.Logger, name, query string, args ...interface{}) {
	if logger.Level < log.TraceLevel {
		return
	}

	query = strings.ReplaceAll(query, "\t", "")
	query = strings.ReplaceAll(query, "\n", " ")
	query = buildQueryWithArgs(query, args)

	logger.Tracef("%s query: %s", name, query)
}

func buildQueryWithArgs(query string, args []interface{}) string {
	if len(args) == 0 {
		return query
	}

	if v, ok := args[0].(map[string]interface{}); ok {
		// args as map
		for k, v := range v {
			tag := fmt.Sprintf(":%s", k)
			value := fmt.Sprintf("%v", v)
			query = strings.ReplaceAll(query, tag, value)
		}
	} else {
		// args as variadic args list
		for i, v := range args {
			tag := fmt.Sprintf("$%d", i+1)
			value := fmt.Sprintf("%v", v)
			query = strings.Replace(query, tag, value, 1)
		}
	}

	return query
}
