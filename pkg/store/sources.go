/*
Copyright 2020 Adevinta
*/

package store

import (
	"context"
	"errors"
	"fmt"
	"hash/fnv"
	"sort"
	"time"

	"github.com/jmoiron/sqlx"
)

// Source represents a source
// which reports vulnerabilities.
type Source struct {
	ID       string
	Instance string
	Options  string
	Time     time.Time
	SourceFamily
}

// SourceFamily represents the set of sources with same
// name, component and target.
type SourceFamily struct {
	Name      string
	Component string
	Target    string `db:"target_id"`
}

// SourceFamilies represents a slice of SourceFamily elements.
type SourceFamilies []SourceFamily

// Sort sorts families alphabetically by Name and Component.
func (sff SourceFamilies) Sort() {
	sort.Slice(sff, func(i, j int) bool {
		sfI := sff[i]
		sfJ := sff[j]

		var strI, strJ string
		if sfI.Name != sfJ.Name {
			// Compare names
			strI = sfI.Name
			strJ = sfJ.Name

		} else {
			// Compare components
			strI = sfI.Component
			strJ = sfJ.Component
		}
		return strI < strJ
	})
}

// SourceFinding represents a finding found by a source in a target
// with a given score for that target.
type SourceFinding struct {
	IssueID                string  `db:"issue_id"`
	Score                  float32 `db:"score"`
	Details                string
	ImpactDetails          string `db:"impact_details"`
	AffectedResource       string `db:"affected_resource"`
	AffectedResourceString string `db:"affected_resource_string"`
	Fingerprint            string `db:"fingerprint"`
	Resources              *[]byte
}

func (db *psqlxStore) CreateSourceIfNotExists(s Source) (*Source, error) {

	tx, err := db.DB.BeginTxx(context.Background(), nil)
	if err != nil {
		return nil, err
	}
	source, err := createSourceIfNotExists(context.Background(), tx, s)
	if err != nil {
		return nil, err
	}
	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return source, nil
}

// GetOpenSourceFindings returns the tuple issue_id,score for the findings that
// have been found by a given the source.
func (db *psqlxStore) GetOpenSourceFindings(id string) ([]SourceFinding, error) {
	openFindingsForSource := `
	SELECT distinct f.issue_id as issue_id, fe.score as score, f.affected_resource
	FROM findings f JOIN finding_events fe on fe.finding_id=f.id 
	JOIN sources s on s.id = fe.source_id
	WHERE f.status='OPEN' AND fe.source_id = $1`
	sf := []SourceFinding{}
	err := db.DB.Select(&sf, openFindingsForSource, id)
	if err != nil && !IsNotFoundErr(err) {
		return nil, err
	}
	return sf, nil
}

// ProcessSourceExecution updates the store from a source and the issues it has found.
func (db *psqlxStore) ProcessSourceExecution(s Source, sourceFindings []SourceFinding) (Source, error) {
	ctx := context.Background()
	tx, err := db.DB.BeginTxx(ctx, nil)
	if err != nil {
		return Source{}, err
	}

	screated, err := createSource(ctx, tx, s)
	if err != nil {
		tx.Rollback()
		return Source{}, err
	}
	if screated == nil {
		return Source{}, errors.New("unexpected nil pointer after source creation")
	}

	// Before updating the findings we have to lock the tx to prevent race
	// conditions from other possible concurrent sources being processed.
	// To do that we have to lock based on all related sources that can
	// have an effect on the current source being processed and its findings.
	relatedFamilies, err := db.relatedFamilies(s.SourceFamily)
	if err != nil {
		return Source{}, err
	}
	err = db.lockTxBySources(tx, relatedFamilies)
	if err != nil {
		return Source{}, err
	}

	for _, sf := range sourceFindings {
		err = createSourceIssue(ctx, tx, sf.IssueID, screated.ID)
		if err != nil {
			tx.Rollback() // nolint
			return Source{}, err
		}
		f := Finding{
			IssueID:                sf.IssueID,
			TargetID:               s.Target,
			AffectedResource:       sf.AffectedResource,
			AffectedResourceString: sf.AffectedResourceString,
			Fingerprint:            sf.Fingerprint,
			Status:                 FindingStatusNew,
			Details:                sf.Details,
			ImpactDetails:          sf.ImpactDetails,
			Resources:              sf.Resources,
		}
		fe, err := createFindingEvent(ctx, tx, f, *screated, sf.Score, sf.Resources, sf.Details, sf.Fingerprint, sf.AffectedResourceString)
		if err != nil {
			tx.Rollback() // nolint
			return Source{}, err
		}
		err = updateLastSource(ctx, tx, fe.FindingID, screated.ID, screated.Time)
		if err != nil {
			tx.Rollback() // nolint
			return Source{}, err
		}
	}

	findingStates, err := findingsStates(ctx, tx, db.logger, screated.SourceFamily)
	if err != nil {
		tx.Rollback()
		return Source{}, err
	}

	err = replaceFindingsState(ctx, tx, db.logger, findingStates)
	if err != nil {
		tx.Rollback()
		return Source{}, err
	}

	return *screated, tx.Commit()
}

func (db *psqlxStore) CreateSource(s Source) (*Source, error) {
	// Open a new session so we can use postgres session advisory locks to
	// avoid race conditions when processing sources for the same source family
	// and target.
	c, _ := db.DB.Conn(context.Background())
	r := c.QueryRowContext(context.Background(), `INSERT 
	INTO sources (name, component, instance, options, time, target_id) VALUES ($1, $2, $3, $4, $5, $6) 
	RETURNING *`, s.Name, s.Component, s.Instance, s.Options, s.Time, s.Target)
	var created Source
	err := r.Scan(&created)
	return &created, err
}

func (db *psqlxStore) FindSource(s Source) (*Source, error) {
	foundSource := Source{}
	err := db.DB.Get(&foundSource, "SELECT * FROM sources WHERE name = $1 AND component = $2 AND options = $3 AND instance = $4",
		s.Name, s.Component, s.Options, s.Instance)
	if err != nil {
		return nil, err
	}

	return &foundSource, nil
}

func (db *psqlxStore) SourceFamilies() (SourceFamilies, error) {
	q := `SELECT s.name,s.component,s.target_id 
	FROM sources s 
	GROUP BY s.name,s.component,s.target_id`
	s := SourceFamilies{}
	err := db.DB.Select(&s, q)
	if err != nil && !IsNotFoundErr(err) {
		return nil, err
	}
	return s, nil
}

// RelatedFamilies returns the related families for the input SourceFamily.
// That is the source families that are capable of detecting at least one
// of the issues that the input source has ever detected for the specified target.
func (db *psqlxStore) relatedFamilies(sf SourceFamily) (SourceFamilies, error) {
	q := `
	SELECT s.name, s.component, s.target_id
	FROM sources s
	WHERE s.target_id = $3 AND s.component IN (
		SELECT s.component
		FROM sources s INNER JOIN source_issues si ON si.source_id = s.id
		WHERE s.target_id = $3 AND si.issue_id IN (
			SELECT si.issue_id FROM source_issues si
			INNER JOIN sources s ON si.source_id = s.id 
			WHERE name=$1 AND component=$2  AND target_id = $3
		)
	)`

	args := []interface{}{sf.Name, sf.Component, sf.Target}
	logQuery(db.logger, "relatedFamilies", q, args...)
	families := SourceFamilies{}
	err := db.DB.Select(&families, q, args...)
	if err != nil && !IsNotFoundErr(err) {
		return nil, err
	}

	return families, nil
}

// lockTxBySources performs an exclusive advisory lock on the given
// transaction genereting a lock for each specified source family.
func (db *psqlxStore) lockTxBySources(tx *sqlx.Tx, sff SourceFamilies) error {
	// We use advisory locks and transactions to avoid race conditions
	// and inconsistent DB state, for instance, with a source without its
	// finding events, that would lead to wrong findind exposures calculation.

	sff.Sort()

	for _, sf := range sff {
		// A lock is obtained for every source family in scope.
		// The key for the lock is built by concatenating the
		// Name, Component and Target for each source family.
		fkey := fmt.Sprintf("%s%s%s", sf.Name, sf.Component, sf.Target)

		h := fnv.New32()
		h.Write([]byte(fkey))
		k := h.Sum32()

		_, err := tx.Exec("SELECT pg_advisory_xact_lock($1)", k)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	return nil
}

func createSource(ctx context.Context, tx *sqlx.Tx, s Source) (*Source, error) {
	r := tx.QueryRowxContext(ctx, `INSERT INTO sources (name, component, instance, options, time, target_id) 
	  VALUES ($1, $2, $3, $4, $5, $6) RETURNING *`, s.Name, s.Component, s.Instance, s.Options, s.Time, s.Target)
	err := r.StructScan(&s)
	if err != nil {
		return nil, err
	}
	return &s, nil
}

func createSourceIfNotExists(ctx context.Context, tx *sqlx.Tx, s Source) (*Source, error) {
	var err error
	q := `
	WITH  q as (
    SELECT * FROM sources 
	WHERE name=$1 AND component=$2 AND instance=$3 AND options=$4
	), 
	c AS (
      INSERT INTO sources (name, component, instance, options, time, target_id) 
      SELECT $1, $2, $3, $4, $5, $6
      WHERE NOT EXISTS (SELECT 1 FROM q)
      RETURNING *
    )
    SELECT * FROM c
    UNION ALL
	SELECT * FROM q`

	r := tx.QueryRowContext(ctx, q,
		s.Name, s.Component, s.Instance, s.Options, s.Time, s.Target)
	var created Source

	err = r.Scan(&created.ID, &created.Name, &created.Component, &created.Instance,
		&created.Options, &created.Time, &created.Target)

	return &created, err
}

// updateLastSource inserts or updates information about last source for specified finding.
// Last sources table stores, for each finding, the ID of the last source that detected it.
// This is precalculated so it improves performance for other queries like list findings.
func updateLastSource(ctx context.Context, tx *sqlx.Tx, findingID, sourceID string, sourceTime time.Time) error {
	// If there is no last_source record for the finding, then insert.
	// If there's a PK conflict for finding_id, then update source_id for the existent record
	// only if source time is after the time for the currently stored source.
	_, err := tx.ExecContext(ctx, `INSERT INTO last_sources (finding_id, source_id) VALUES ($1, $2)
		ON CONFLICT (finding_id) DO UPDATE SET source_id = $2 WHERE 1 = (
			SELECT 1 FROM SOURCES s INNER JOIN last_sources ls ON ls.source_id = s.id
			WHERE ls.finding_id = $1 AND s.time < $3
		)`, findingID, sourceID, sourceTime)
	return err
}
