/*
Copyright 2020 Adevinta
*/

package results

import (
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
)

const (
	mockReport = `{"check_id":"38063c2e-1595-4d8b-b94f-59a05d740e43","checktype_name":"vulcan-nessus","checktype_version":"120","status":"FINISHED","target":"example.com","options":"{\"policy_id\":10,\"basic_auth\":true}","tag":"","vulnerabilities":[{"id":"","summary":"Nessus Scan Information","score":0,"description":"This plugin displays, for each tested host, information about the\nscan itself :\n\n  - The version of the plugin set.\n  - The type of scanner (Nessus or Nessus Home).\n  - The version of the Nessus Engine.\n  - The port scanner(s) used.\n  - The port range scanned.\n  - Whether credentialed or third-party patch management\n    checks are possible.\n  - The date of the scan.\n  - The duration of the scan.\n  - The number of hosts scanned in parallel.\n  - The number of checks done in parallel.","details":"Information about this scan : \n\nNessus version : 7.0.0\nPlugin feed version : 201812281741\nScanner edition used : Nessus\n\nERROR: Your plugins have not been updated since 2018/12/28\nPerforming a scan with an older plugin set will yield out-of-date results and\nproduce an incomplete audit. Please run nessus-update-plugins to get the\nnewest vulnerability checks from Nessus.org.\n\nScan type : Normal\nScan policy used : full-scan\nScanner IP : 10.249.136.12\nPort scanner(s) : nessus_syn_scanner \nPort range : default\nThorough tests : no\nExperimental tests : no\nParanoia level : 1\nReport verbosity : 1\nSafe checks : yes\nOptimize the test : yes\nCredentialed checks : no\nPatch management checks : None\nCGI scanning : disabled\nWeb application tests : disabled\nMax hosts : 100\nMax checks : 5\nRecv timeout : 5\nBackports : None\nAllow post-scan editing: Yes\nScan Start Date : 2019/7/8 14:43 UTC\nScan duration : 388 sec\n\n","impact_details":"This plugin displays information about the Nessus scan.","recommendations":["n/a"],"resources":[{"Name":"Network Resources","Header":["Hostname","Port","Protocol","Service"],"Rows":[{"Hostname":"example.com","Port":"0","Protocol":"tcp","Service":""}]}],"vulnerabilities":null},{"id":"","summary":"Host Fully Qualified Domain Name (FQDN) Resolution","score":0,"description":"Nessus was able to resolve the fully qualified domain name (FQDN) of\nthe remote host.","details":"\n152.90.236.7 resolves as example.com.\n\n","impact_details":"It was possible to resolve the name of the remote host.","recommendations":["n/a"],"resources":[{"Name":"Network Resources","Header":["Hostname","Port","Protocol","Service"],"Rows":[{"Hostname":"example.com","Port":"0","Protocol":"tcp","Service":""}]}],"vulnerabilities":null},{"id":"","summary":"Nessus SYN scanner","score":0,"description":"This plugin is a SYN 'half-open' port scanner.  It shall be reasonably\nquick even against a firewalled target. \n\nNote that SYN scans are less intrusive than TCP (full connect) scans\nagainst broken services, but they might cause problems for less robust\nfirewalls and also leave unclosed connections on the remote target, if\nthe network is loaded.","details":"Port 22/tcp was found to be open\nPort 25/tcp was found to be open\nPort 80/tcp was found to be open\nPort 111/tcp was found to be open\nPort 443/tcp was found to be open\n","impact_details":"It is possible to determine which TCP ports are open.","recommendations":["Protect your target with an IP filter."],"resources":[{"Name":"Network Resources","Header":["Hostname","Port","Protocol","Service"],"Rows":[{"Hostname":"example.com","Port":"22","Protocol":"tcp","Service":""},{"Hostname":"example.com","Port":"25","Protocol":"tcp","Service":""},{"Hostname":"example.com","Port":"80","Protocol":"tcp","Service":""},{"Hostname":"example.com","Port":"111","Protocol":"tcp","Service":""},{"Hostname":"example.com","Port":"443","Protocol":"tcp","Service":""}]}],"vulnerabilities":null}],"error":"","start_time":"2019-07-08 14:43:49","end_time":"2019-07-08 14:50:28"}`
)

func TestDownload(t *testing.T) {
	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json")
		io.WriteString(w, mockReport)
	}))
	defer mockServer.Close()

	tests := []struct {
		name            string
		reportURL       string
		mockReport      string
		expectedErr     error
		expectedCheckID string
	}{
		{
			name:            "Should download report",
			reportURL:       mockServer.URL,
			mockReport:      mockReport,
			expectedErr:     nil,
			expectedCheckID: "38063c2e-1595-4d8b-b94f-59a05d740e43",
		},
		{
			name:            "Should return err invalid report URL",
			reportURL:       "",
			mockReport:      "",
			expectedErr:     ErrInvalidURL,
			expectedCheckID: "",
		},
	}

	client := reportClient{}

	for _, tt := range tests {
		report, err := client.Download(tt.reportURL)
		if err != tt.expectedErr {
			t.Fatalf("Error downloading report. Expected error '%v', but got '%v'", tt.expectedErr, err)
		}
		if report.CheckID != tt.expectedCheckID {
			t.Fatalf("Error, expected check ID '%s', but got '%s'", tt.expectedCheckID, report.CheckID)
		}
	}
}
