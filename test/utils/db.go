//go:build integration
// +build integration

/*
Copyright 2020 Adevinta
*/

package utils

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq" // postgres driver
)

var (
	dbPort               = "5432" //default port, can be overriden by TEST_DB_PORT environment variable
	defaultFlywayVersion = "8"
)

const (
	// DB Conn. str template.
	dbConnStrFmt = "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s"

	// Test DB config.
	dbHost    = "127.0.0.1"
	dbUser    = "vulndb_test"
	dbPass    = "vulndb_test"
	dbName    = "vulndb_test"
	dbSSLMode = "disable"

	// Relative db dir path.
	dbDirPath = "../db"

	// Flyway commands.
	flywayClean   = "clean"
	flywayMigrate = "migrate"

	// DB tables.
	FEventsTable    = "finding_events"
	FExposuresTable = "finding_exposures"
	FindingsTable   = "findings"
	IssuesTable     = "issues"
	SourcesTable    = "sources"
	TargetsTable    = "targets"

	// Query statements.
	sourcesStmt    = "SELECT id as source_id, * FROM sources WHERE instance = :instance"
	targetsStmt    = "SELECT id as target_id, * FROM targets WHERE identifier = :identifier"
	issuesStmt     = "SELECT id as issue_id, * FROM issues WHERE summary = :summary AND description = :description"
	findingsStmt   = "SELECT id as finding_id, * FROM findings WHERE issue_id = :issue_id AND target_id = :target_id and affected_resource = :affected_resource"
	fEventsStmt    = "SELECT * FROM finding_events WHERE finding_id = :finding_id AND time = :time"
	fExposuresStmt = "SELECT * FROM finding_exposures WHERE finding_id = :finding_id AND found_at = :found_at"
)

func init() {
	if envDBPort := os.Getenv("TEST_DB_PORT"); envDBPort != "" {
		dbPort = envDBPort
	}
}

// DBConnStr returns the connection
// str for postgres test db.
func DBConnStr() string {
	return fmt.Sprintf(dbConnStrFmt, dbHost, dbPort, dbUser, dbPass, dbName, dbSSLMode)
}

// DB returns a new sqlx DB.
func DB() (*sqlx.DB, error) {
	return sqlx.Connect("postgres", DBConnStr())
}

// ResetDB cleans the current vulndb database
// in the test postgres container and loads the
// initial schema again.
func ResetDB() error {
	return runFlywayCmd(dbDirPath, flywayClean, flywayMigrate)
}

// runFlywayCmd runs the specified flyway cmd against the
// test postgres container.
func runFlywayCmd(dbDirPath string, flywayCommand ...string) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}
	dir := path.Join(wd, dbDirPath)

	flywayVersion := defaultFlywayVersion
	if value, ok := os.LookupEnv("FLYWAY_VERSION"); ok {
		flywayVersion = value
	}

	cmdName := "docker"
	cmdArgs := []string{
		"run",
		"--net=host",
		"--rm",
		"-v",
		dir + ":/flyway/sql",
		"flyway/flyway:" + flywayVersion + "-alpine",
		"-q",
		"-community",
		"-user=" + dbUser,
		"-password=" + dbPass,
		"-url=jdbc:postgresql://" + dbHost + ":" + dbPort + "/" + dbName,
		"-baselineOnMigrate=true",
		"-cleanDisabled=false",
	}
	cmdArgs = append(cmdArgs, flywayCommand...)

	cmd := exec.Command(cmdName, cmdArgs...)
	cmd.Env = os.Environ()
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("Error executing flyway command, command output:\n%s.\n Error:\n %s", output, err)
	}
	return nil
}

// FetchData retrieves data from test db.
// Because DB IDs are autogenerated, we can not query by them,
// so we have to retrieve data based on other attributes.
// E.g.: Issue{summary, description}, target{identifier}, etc.
func FetchDBData(table string, args map[string]interface{}, db *sqlx.DB) (map[string]interface{}, error) {
	var stmt string

	switch table {
	case SourcesTable:
		stmt = sourcesStmt
	case TargetsTable:
		stmt = targetsStmt
	case IssuesTable:
		stmt = issuesStmt
	case FindingsTable:
		stmt = findingsStmt
	case FEventsTable:
		stmt = fEventsStmt
	case FExposuresTable:
		stmt = fExposuresStmt
	}

	if stmt == "" {
		return nil, errors.New("Table not supported")
	}

	nstmt, err := db.PrepareNamed(stmt)
	rows, err := nstmt.Queryx(args)
	if err != nil {
		return nil, err
	}

	data := make(map[string]interface{})
	if rows.Next() {
		if err = rows.MapScan(data); err != nil {
			return nil, err
		}
	}

	if rows.Next() {
		return nil, errors.New(fmt.Sprintf("Multiple results. Table %v. Args %v. Stmt %v", table, args, stmt))
	}

	return data, nil
}
