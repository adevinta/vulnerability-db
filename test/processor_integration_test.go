// +build integration

/*
Copyright 2020 Adevinta
*/

package test

import (
	"encoding/json"
	"fmt"
	"reflect"
	"sync"
	"testing"
	"time"

	"github.com/adevinta/vulnerability-db/pkg/processor"
	"github.com/adevinta/vulnerability-db/pkg/store"
	"github.com/jmoiron/sqlx"
	"github.com/sirupsen/logrus/hooks/test"
)

const (
	// Default maxEventAge (days).
	maxEventAge = 0

	// DB tables.
	fEventsTable    = "finding_events"
	fExposuresTable = "finding_exposures"
	findingsTable   = "findings"
	issuesTable     = "issues"
	sourcesTable    = "sources"
	targetsTable    = "targets"
	tTagsTable      = "target_tags"

	// timeFmt.
	timeFmt = "2006-01-02 15:04:05"
)

// Mock notifier.
type mockNotifier struct {
	pushEvents uint32
}

func (n *mockNotifier) Push(mssg interface{}) error {
	n.pushEvents++
	return nil
}

// expectedData struct defines
// expected DB data.
type expectedData struct {
	table string
	data  map[string]interface{}
}

func TestProcessor(t *testing.T) {
	// testCases holds the specs for the test  cases to verify the correct
	// behavior of the processor.
	//
	// The main point of verification is the correct processing and storing
	// of all data related to check message and its report. This is done by
	// retrieving inserted data from test DB and comparing it with the defined
	// expected one.
	// Expected data objects should be specified following an "increasing
	// object relation complexity order". That means that more complext objects
	// should be defined after simpler ones.
	// This is due to the fact that more complex objects might require the IDs
	// of simpler objects to be uniquely identified and retrieved. Because these
	// IDs are auto generated by the DB we can not fix them in the test specs
	// and, instead, have to retrieve them during test execution.
	// E.g.: Expected findings should be specified after issues and targets.
	//
	// Other considerations regarding expected data:
	// - Integer values must be casted to int64 because that's the type the
	//   DB driver will parse it to when retrieving.
	// - Float values should be casted to float64 and be .0 decimals to
	//   simplify verification because otherwise there are some errors
	//   regarding precision comparison using reflect.DeepEqual.
	//   E.g.: 8.9 is stored and retrieved as 8.899996.
	testCases := []struct {
		name      string
		checkData string
		expected  []expectedData
	}{
		{
			name: "Happy path",
			checkData: `
			{
		        "id":"00000000-0000-0000-0000-000000000001",
		        "checktype_name":"vulcan-mock-check",
		        "status":"FINISHED",
		        "target":"www.adevinta.com",
		        "options":"{}",
		        "report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000001.json",
		        "tag":"adrn:adevinta:team:security"
			}`,
			expected: []expectedData{
				expectedData{
					table: issuesTable,
					data: map[string]interface{}{
						"summary":     "Managed AWS databases using CA about to expire",
						"description": "Mock description",
						"cwe_id":      int64(216),
					},
				},
				expectedData{
					table: targetsTable,
					data: map[string]interface{}{
						"identifier": "www.adevinta.com",
					},
				},
				expectedData{
					table: tTagsTable,
					data: map[string]interface{}{
						"tag": "adrn:adevinta:team:security",
					},
				},
				expectedData{
					table: sourcesTable,
					data: map[string]interface{}{
						"name":      "vulcan",
						"component": "vulcan-mock-check",
						"instance":  "00000000-0000-0000-0000-000000000001",
						"options":   "{}",
					},
				},
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"status":    "OPEN",
						"score":     float64(8.0),
						"details":   "Managed AWS details",
						"resources": []byte(`[{"name": "resource name", "resources": null, "attributes": null}]`),
					},
				},
				expectedData{
					table: fEventsTable,
					data: map[string]interface{}{
						"time":      "2020-01-21 16:03:25",
						"score":     float64(8.0),
						"details":   "Managed AWS details",
						"resources": []byte(`[{"name": "resource name", "resources": null, "attributes": null}]`),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at": "2020-01-21 16:03:25",
						"fixed_at": nil,
						"ttr":      nil,
					},
				},
			},
		},
		{
			name: "Should fix initial finding",
			checkData: `
			{
				"id":"00000000-0000-0000-0000-000000000002",
				"checktype_name":"vulcan-initial-check",
				"status":"FINISHED",
				"target":"www.initial.example.com",
				"options":"{}",
				"report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000002.json",
				"tag":"adrn:adevinta:team:initial"
			}`,
			expected: []expectedData{
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"issue_id":  "c0000000-0000-0000-0000-000000000001",
						"target_id": "a0000000-0000-0000-0000-000000000001",
						"status":    "FIXED",
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at": "2020-01-01 00:00:00",
						"fixed_at": "2020-01-01 10:00:00",
						"ttr":      int64(10),
					},
				},
			},
		},
		{
			name: "Should create new finding event for initial finding",
			checkData: `
			{
				"id":"00000000-0000-0000-0000-000000000003",
				"checktype_name":"vulcan-initial-check",
				"status":"FINISHED",
				"target":"www.initial.example.com",
				"options":"{}",
				"report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000003.json",
				"tag":"adrn:adevinta:team:initial"
			}`,
			expected: []expectedData{
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"issue_id":  "c0000000-0000-0000-0000-000000000001",
						"target_id": "a0000000-0000-0000-0000-000000000001",
						"status":    "OPEN",
						"score":     float64(7.0),
						"details":   "Managed AWS details - modified",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-2009-3023"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at": "2020-01-01 00:00:00",
						"fixed_at": nil,
						"ttr":      nil,
					},
				},
				expectedData{
					table: fEventsTable,
					data: map[string]interface{}{
						"score":     float64(7.0),
						"time":      "2020-01-02 10:00:00",
						"details":   "Managed AWS details - modified",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-2009-3023"}], "attributes": ["CVE"]}]`),
					},
				},
			},
		},
		{
			name: "Should reopen initial fixed finding",
			checkData: `
			{
				"id":"00000000-0000-0000-0000-000000000004",
				"checktype_name":"vulcan-initial-fixed-check",
				"status":"FINISHED",
				"target":"www.initial.fixed.example.com",
				"options":"{}",
				"report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000004.json",
				"tag":"adrn:adevinta:team:fixed"
			}`,
			expected: []expectedData{
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"issue_id":  "c0000000-0000-0000-0000-000000000002",
						"target_id": "a0000000-0000-0000-0000-000000000002",
						"status":    "OPEN",
						"score":     float64(9.0),
						"details":   "Initial fixed issue details",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-8888-9999"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at": "2020-01-03 01:00:00",
						"fixed_at": nil,
						"ttr":      nil,
					},
				},
				expectedData{
					table: fEventsTable,
					data: map[string]interface{}{
						"score":     float64(9.0),
						"time":      "2020-01-03 01:00:00",
						"details":   "Initial fixed issue details",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-8888-9999"}], "attributes": ["CVE"]}]`),
					},
				},
			},
		},
		{
			name: "Should reopen initial fixed finding via 'cross checktype'",
			checkData: `
			{
				"id":"00000000-0000-0000-0000-000000000005",
				"checktype_name":"vulcan-cross-checktype-check",
				"status":"FINISHED",
				"target":"www.initial.fixed.example.com",
				"options":"{}",
				"report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000005.json",
				"tag":"adrn:adevinta:team:fixed"
			}`,
			expected: []expectedData{
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"issue_id":  "c0000000-0000-0000-0000-000000000002",
						"target_id": "a0000000-0000-0000-0000-000000000002",
						"status":    "OPEN",
						"score":     float64(6.0),
						// Score is overwritten by latest check. TODO: Rethink about this situation.
						"details":   "Initial fixed issue details - modified",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-9999-9999"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at": "2020-01-03 01:00:00",
						"fixed_at": nil,
						"ttr":      nil,
					},
				},
				expectedData{
					table: fEventsTable,
					data: map[string]interface{}{
						"score":     float64(6.0),
						"time":      "2020-01-03 01:00:00",
						"details":   "Initial fixed issue details - modified",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-9999-9999"}], "attributes": ["CVE"]}]`),
					},
				},
			},
		},
		{
			name: "Should open multiple new findings",
			checkData: `
			{
				"id":"00000000-0000-0000-0000-000000000006",
				"checktype_name":"vulcan-new-check",
				"status":"FINISHED",
				"target":"www.new.example.com",
				"options":"{}",
				"report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000006.json",
				"tag":"adrn:adevinta:team:new"
			}`,
			expected: []expectedData{
				expectedData{
					table: issuesTable,
					data: map[string]interface{}{
						"summary":     "New issue one",
						"description": "New issue one description",
						"cwe_id":      int64(3),
					},
				},
				expectedData{
					table: targetsTable,
					data: map[string]interface{}{
						"identifier": "www.new.example.com",
					},
				},
				expectedData{
					table: tTagsTable,
					data: map[string]interface{}{
						"tag": "adrn:adevinta:team:new",
					},
				},
				expectedData{
					table: sourcesTable,
					data: map[string]interface{}{
						"name":      "vulcan",
						"component": "vulcan-new-check",
						"instance":  "00000000-0000-0000-0000-000000000006",
						"options":   "{}",
					},
				},
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"status":    "OPEN",
						"score":     float64(5.0),
						"details":   "New issue one details",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-0000-0001"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fEventsTable,
					data: map[string]interface{}{
						"score":     float64(5.0),
						"time":      "2020-01-04 01:00:00",
						"details":   "New issue one details",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-0000-0001"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at": "2020-01-04 01:00:00",
						"fixed_at": nil,
						"ttr":      nil,
					},
				},
				expectedData{
					table: issuesTable,
					data: map[string]interface{}{
						"summary":     "New issue two",
						"description": "New issue two description",
						"cwe_id":      int64(4),
					},
				},
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						// issue_id will be overwritten in
						// related data map when parsing this
						// due to just retrieved issue, which
						// will lead to new finding 'two'
						// being retrieved instead of 'one'.
						"status":    "OPEN",
						"score":     float64(6.0),
						"details":   "New issue two details",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-0000-0002"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fEventsTable,
					data: map[string]interface{}{
						"score":     float64(6.0),
						"time":      "2020-01-04 01:00:00",
						"details":   "New issue two details",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-0000-0002"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at": "2020-01-04 01:00:00",
						"fixed_at": nil,
						"ttr":      nil,
					},
				},
			},
		},
		{
			name: "Should reopen initially EXPIRED finding",
			checkData: `
			{
				"id":"00000000-0000-0000-0000-000000000007",
				"checktype_name":"vulcan-initial-expired-check",
				"status":"FINISHED",
				"target":"www.initial.expired.example.com",
				"options":"{}",
				"report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000007.json",
				"tag":"adrn:adevinta:team:expired"
			}`,
			expected: []expectedData{
				expectedData{
					table: issuesTable,
					data: map[string]interface{}{
						"summary":     "Initial expired issue",
						"description": "Initial expired issue description",
						"cwe_id":      int64(2),
					},
				},
				expectedData{
					table: targetsTable,
					data: map[string]interface{}{
						"identifier": "www.initial.expired.example.com",
					},
				},
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"status":    "OPEN",
						"score":     float64(9.0),
						"details":   "Initial expired issue details",
						"resources": []byte(`[{"name": "resource name", "resources": [{"CVE": "CVE-1111-1111"}], "attributes": ["CVE"]}]`),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at":   "2020-01-01 01:00:00",
						"fixed_at":   nil,
						"ttr":        nil,
						"expired_at": nil,
					},
				},
			},
		},
		{
			name: "Should fix initially EXPIRED finding",
			checkData: `
			{
				"id":"00000000-0000-0000-0000-000000000007",
				"checktype_name":"vulcan-initial-expired-check",
				"status":"FINISHED",
				"target":"www.initial.expired.example.com",
				"options":"{}",
				"report":"https://dummy.com/v1/reports/00000000-0000-0000-0000-000000000008.json",
				"tag":"adrn:adevinta:team:expired"
			}`,
			expected: []expectedData{
				expectedData{
					table: issuesTable,
					data: map[string]interface{}{
						"summary":     "Initial expired issue",
						"description": "Initial expired issue description",
						"cwe_id":      int64(2),
					},
				},
				expectedData{
					table: targetsTable,
					data: map[string]interface{}{
						"identifier": "www.initial.expired.example.com",
					},
				},
				expectedData{
					table: findingsTable,
					data: map[string]interface{}{
						"status": "FIXED",
						"score":  float64(9.0),
					},
				},
				expectedData{
					table: fExposuresTable,
					data: map[string]interface{}{
						"found_at":   "2020-01-01 01:00:00",
						"fixed_at":   "2020-03-01 01:00:00",
						"ttr":        int64(1440),
						"expired_at": nil,
					},
				},
			},
		},
	}

	testDB, err := db()
	if err != nil {
		t.Fatalf("Error connecting to test DB: %v", err)
	}

	checksProcessor := setupProcessor(t)

	for _, tc := range testCases {
		err := resetDB()
		if err != nil {
			t.Fatalf("Error resetting DB: %v", err)
		}

		t.Run(tc.name, func(t *testing.T) {
			// Serialize check data into a mock
			// SNS notification.
			checkMssg, err := serializeCheckMssg(tc.checkData)
			if err != nil {
				t.Fatalf("Error serializing check mssg: %v", err)
			}

			// Process check message.
			err = checksProcessor.ProcessMessage(checkMssg)
			if err != nil {
				t.Fatalf("Error processing mssg: %v", err)
			}

			// Check expected data.
			err = checkData(t, tc.expected, testDB)
			if err != nil {
				t.Fatalf("Error checking expected data: %v", err)
			}
		})
	}
}

// TestProcessorConcurrency tests the checks processor concurrency
// when processing multiple check messages related to the same finding.
// Additionally, the check messages are not correlative, that means that
// the order of the messages in the 'queue' (a slice iterated from 0..N)
// does not match their execution order.
//
// To test this we create a processor pool with one processor for each
// message in the queue, and concurrenlty make each processor process
// one of the messages. We wait for the processors to finish, and then
// compare the DB data with the expected data. In this case the main
// fields to verify are the finding status and the finding exposures,
// becouse these are the fields that can particularly be messed up
// when handling concurrency wrongly.
func TestProcessorConcurrency(t *testing.T) {

	// checks is a slice of unordered check messages.
	// That means that their position in the slice does not represent
	// the time of execution specified in the reports related to them.
	// (For 'test reading clearness', check IDs specify the real
	// check execution order).
	checks := []string{
		`{
			"id":"10000000-0000-0000-0000-000000000002",
			"checktype_name":"vulcan-initial-check",
			"status":"FINISHED",
			"target":"www.initial.example.com",
			"options":"{}",
			"report":"https://dummy.com/v1/reports/10000000-0000-0000-0000-000000000002.json",
			"tag":"adrn:adevinta:team:initial"
		}`,
		`{
			"id":"10000000-0000-0000-0000-000000000001",
			"checktype_name":"vulcan-initial-check",
			"status":"FINISHED",
			"target":"www.initial.example.com",
			"options":"{}",
			"report":"https://dummy.com/v1/reports/10000000-0000-0000-0000-000000000001.json",
			"tag":"adrn:adevinta:team:initial"
		}`,
		`{
			"id":"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaa",
			"checktype_name":"vulcan-initial-check",
			"status":"FAILED",
			"target":"www.initial.example.com",
			"options":"{}",
			"report":"https://dummy.com/v1/reports/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa.json",
			"tag":"adrn:adevinta:team:initial"
		}`,
		`{
			"id":"10000000-0000-0000-0000-000000000005",
			"checktype_name":"vulcan-initial-check",
			"status":"FINISHED",
			"target":"www.initial.example.com",
			"options":"{}",
			"report":"https://dummy.com/v1/reports/10000000-0000-0000-0000-000000000005.json",
			"tag":"adrn:adevinta:team:initial"
		}`,
		`{
			"id":"10000000-0000-0000-0000-000000000004",
			"checktype_name":"vulcan-initial-check",
			"status":"FINISHED",
			"target":"www.initial.example.com",
			"options":"{}",
			"report":"https://dummy.com/v1/reports/10000000-0000-0000-0000-000000000004.json",
			"tag":"adrn:adevinta:team:initial"
		}`,
		`{
			"id":"10000000-0000-0000-0000-000000000003",
			"checktype_name":"vulcan-initial-check",
			"status":"FINISHED",
			"target":"www.initial.example.com",
			"options":"{}",
			"report":"https://dummy.com/v1/reports/10000000-0000-0000-0000-000000000003.json",
			"tag":"adrn:adevinta:team:initial"
		}`,
	}

	expected := []expectedData{
		expectedData{
			table: sourcesTable,
			data: map[string]interface{}{
				"name":      "vulcan",
				"component": "vulcan-initial-check",
				"instance":  "10000000-0000-0000-0000-000000000001",
				"options":   "{}",
			},
		},
		expectedData{
			table: sourcesTable,
			data: map[string]interface{}{
				"name":      "vulcan",
				"component": "vulcan-initial-check",
				"instance":  "10000000-0000-0000-0000-000000000002",
				"options":   "{}",
			},
		},
		expectedData{
			table: sourcesTable,
			data: map[string]interface{}{
				"name":      "vulcan",
				"component": "vulcan-initial-check",
				"instance":  "10000000-0000-0000-0000-000000000003",
				"options":   "{}",
			},
		},
		expectedData{
			table: sourcesTable,
			data: map[string]interface{}{
				"name":      "vulcan",
				"component": "vulcan-initial-check",
				"instance":  "10000000-0000-0000-0000-000000000004",
				"options":   "{}",
			},
		},
		expectedData{
			table: sourcesTable,
			data: map[string]interface{}{
				"name":      "vulcan",
				"component": "vulcan-initial-check",
				"instance":  "10000000-0000-0000-0000-000000000005",
				"options":   "{}",
			},
		},
		expectedData{
			table: findingsTable,
			data: map[string]interface{}{
				"issue_id":  "c0000000-0000-0000-0000-000000000001",
				"target_id": "a0000000-0000-0000-0000-000000000001",
				"score":     float64(7.0),
				"status":    "FIXED",
			},
		},
		expectedData{
			table: fEventsTable,
			data: map[string]interface{}{
				"finding_id": "f0000000-0000-0000-0000-000000000001",
				"score":      float64(7.0),
				"time":       "2020-01-02 01:00:00",
			},
		},
		expectedData{
			table: fEventsTable,
			data: map[string]interface{}{
				"finding_id": "f0000000-0000-0000-0000-000000000001",
				"score":      float64(7.0),
				"time":       "2020-01-04 01:00:00",
			},
		},
		expectedData{
			table: fEventsTable,
			data: map[string]interface{}{
				"finding_id": "f0000000-0000-0000-0000-000000000001",
				"score":      float64(7.0),
				"time":       "2020-01-05 01:00:00",
			},
		},
		expectedData{
			table: fExposuresTable,
			data: map[string]interface{}{
				"finding_id": "f0000000-0000-0000-0000-000000000001",
				"found_at":   "2020-01-01 00:00:00",
				"fixed_at":   "2020-01-03 01:00:00",
				"ttr":        int64(24*2 + 1),
			},
		},
		expectedData{
			table: fExposuresTable,
			data: map[string]interface{}{
				"finding_id": "f0000000-0000-0000-0000-000000000001",
				"found_at":   "2020-01-04 01:00:00",
				"fixed_at":   "2020-01-06 01:00:00",
				"ttr":        int64(24 * 2),
			},
		},
	}

	testDB, err := db()
	if err != nil {
		t.Fatalf("Error connecting to test DB: %v", err)
	}
	err = resetDB()
	if err != nil {
		t.Fatalf("Error resetting DB: %v", err)
	}

	processorsPool := make([]*processor.CheckProcessor, len(checks))
	for i := 0; i < len(checks); i++ {
		processorsPool[i] = setupProcessor(t)
	}

	var wg sync.WaitGroup
	for i, c := range checks {
		wg.Add(1)
		go func(processor *processor.CheckProcessor, check string, wg *sync.WaitGroup) {
			// Serialize check data into a mock
			// SNS notification.
			checkMssg, err := serializeCheckMssg(check)
			if err != nil {
				return
			}

			// Process check message.
			err = processor.ProcessMessage(checkMssg)
			if err != nil {
				return
			}

			wg.Done()
		}(processorsPool[i], c, &wg)
	}

	wg.Wait()

	err = checkData(t, expected, testDB)
	if err != nil {
		t.Fatalf("Error checking expected data: %v", err)
	}
}

func setupProcessor(t *testing.T) *processor.CheckProcessor {
	t.Helper()

	// Build logger.
	logger, _ := test.NewNullLogger()
	// Build notifier.
	notifier := &mockNotifier{}
	// Build results client.
	resultsClient := &mockResultsClient{}
	// Build DB.
	db, err := store.NewDB(dbConnStr(), logger)
	if err != nil {
		t.Fatalf("Error connecting to DB: %v", err)
	}

	// Build processor.
	processor, err := processor.NewCheckProcessor(notifier, db, resultsClient, "", maxEventAge, logger)
	if err != nil {
		t.Fatalf("Error building processor: %v", err)
	}
	return processor
}

// checkData verifies expected data against data in test DB.
func checkData(t *testing.T, expected []expectedData, db *sqlx.DB) error {
	t.Helper()

	// relatedData holds accumulative
	// data retrieved from DB for each
	// expected data verification.
	//
	// This is due to the fact that, for
	// example, to retrieve a finding, we
	// need the issue_id and target_id
	// related to it, these are autogenerated
	// by the DB, so we con not fix them on
	// the test data. Instead we retrieve them
	// on each data verification iteration
	// and add them to relatedData map so they
	// can be used on the next iterations to
	// verify more 'complex' objects.
	relatedData := map[string]interface{}{}

	for _, ed := range expected {
		// merge expected data with previously
		// retrieved data in case some field
		// is needed for current DB querying.
		// Set 'overwrite' to true because test
		// expected data always has preference.
		mergeMaps(relatedData, ed.data, true)

		data, err := fetchDBData(ed.table, relatedData, db)
		if err != nil {
			return err
		}

		if !isSameData(ed.data, data) {
			return fmt.Errorf("Expected:\n%v\nBut got:\n%v", ed.data, data)
		}

		// merge current related data
		// with new fetched data so keep
		// collecting related data for
		// next iterations.
		// Set overwrite to true so multiple
		// elements of same type can be retrieved
		// during the same test.
		// (See comment on expected data for test
		// case  'Should open multiple new findings')
		mergeMaps(relatedData, data, true)
	}

	return nil
}

// isSameData compares two maps.
// Returns true if all data in eData map
// is also found in data map.
// Take into consideration that data map
// can have extra data other than the expected.
func isSameData(eData, data map[string]interface{}) bool {
	timeRef := time.Now()

	for k, eValue := range eData {
		value, ok := data[k]
		if !ok {
			return false
		}

		// If value is a Time reference,
		// format it to expected layout.
		if reflect.TypeOf(value) == reflect.TypeOf(timeRef) {
			value = value.(time.Time).Format(timeFmt)
		}

		if !reflect.DeepEqual(value, eValue) {
			return false
		}
	}

	return true
}

// serializeCheckMssg encapsulates the check data into a
// mock SNS notification struct and serializes it into a string.
func serializeCheckMssg(check string) (string, error) {
	notif := processor.Notification{
		Message: check,
	}
	notifJSON, err := json.Marshal(notif)
	return string(notifJSON), err
}

// mergeMaps merges m2 key-values into m1.
// If one key already exists in m1, 'overwrite'
// parameter defines if it is replaced or not.
func mergeMaps(m1, m2 map[string]interface{}, overwrite bool) {
	for k, v := range m2 {
		if _, ok := m1[k]; !ok || overwrite {
			m1[k] = v
		}
	}
}
