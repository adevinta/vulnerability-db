// +build integration

/*
Copyright 2020 Adevinta
*/

package test

import (
	"strings"

	vulcan "github.com/adevinta/vulcan-report"
	"github.com/adevinta/vulnerability-db/pkg/results"
)

// This file contains a mock implementation of the results client.
// This allows us to test the consumer processor without having to
// interact with results service or any mock HTTP service.
// Instead, mockResultsClient will mock the HTTP request and return
// the reports data for a predefined reports list specified in this
// same file.

// Mock reports client.
type mockResultsClient struct {
	init    bool
	reports map[string]vulcan.Report
}

// Init builds the reports map of:
// {check_id: vulcan.Report}
// for every report specified in the
// mock_reports file.
func (c *mockResultsClient) Init() error {
	c.reports = make(map[string]vulcan.Report)

	for _, reportJSON := range reports {
		var r vulcan.Report
		err := r.UnmarshalJSONTimeAsString([]byte(reportJSON))
		if err != nil {
			return err
		}
		c.reports[r.CheckID] = r
	}

	return nil
}

// Download mocks the results client download method
// fetching data from mock reports.
func (c *mockResultsClient) Download(reportURL string) (vulcan.Report, error) {
	// Load report mocks if they've not
	// been loaded yet.
	if !c.init {
		if err := c.Init(); err != nil {
			return vulcan.Report{}, err
		}
		c.init = true
	}

	// Look for report and return if found.
	// Otherwise, return ErrInvalidRespStatus
	// mocking a bad HTTP response from server.
	reportID := parseReportID(reportURL)
	report, ok := c.reports[reportID]
	if !ok {
		return vulcan.Report{}, results.ErrInvalidRespStatus
	}

	return report, nil
}

// parseReportID extracts the report ID from the request url.
// It assumes that the URL path complies with format:
// /v1/reports/dt=YYYY-MM-DD/scan={scan_id}/{check_id}.json
func parseReportID(url string) string {
	// Split url by resources separator '/'.
	urlParts := strings.Split(url, "/")
	// Get report filename. E.g.: {uuid}.json
	reportFile := urlParts[len(urlParts)-1]
	// Remove .json extension.
	return reportFile[:len(reportFile)-len(".json")]
}

var (
	// Mock reports to be used by the mock results client.
	// An external .json file in this package was discarded
	// in favor of this solution (defining them as a JSON
	// string in a go variable) so we could avoid using FS IO.
	//
	// Some attributes have been removed from report JSON because
	// processor does not parse them from the report but from the
	// check message itself.
	reports = []string{
		// Happy path report.
		`{
			"check_id":"00000000-0000-0000-0000-000000000001",
			"vulnerabilities":
				[
					{
						"summary":"Managed AWS databases using CA about to expire",
						"score":8.0,
						"details":"Managed AWS details",
						"cwe_id": 216,
						"description":"Mock description",
						"references":[],
						"resources":[{"name":"resource name"}]
					}
				],
			"start_time":"2020-01-21 16:03:13",
			"end_time":"2020-01-21 16:03:25"
		}`,
		// Report that should set to FIXED the initial finding.
		`{
			"check_id":"00000000-0000-0000-0000-000000000002",
			"vulnerabilities": [],
			"start_time":"2020-01-01 09:00:00",
			"end_time":"2020-01-01 10:00:00"
		}`,
		// Report that adds new finding event to initial finding.
		`{
			"check_id":"00000000-0000-0000-0000-000000000003",
			"vulnerabilities": [
				{
					"summary":"Initial issue",
					"score":7.0,
					"details":"Managed AWS details - modified",
					"cwe_id": 1,
					"description":"Initial issue description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-2009-3023"}], "header": ["CVE"]}]
				}
			],
			"start_time":"2020-01-02 09:00:00",
			"end_time":"2020-01-02 10:00:00"
		}`,
		// Report that reopens the initial fixed finding.
		`{
			"check_id":"00000000-0000-0000-0000-000000000004",
			"vulnerabilities": [
				{
					"summary":"Initial fixed issue",
					"score":9.0,
					"details":"Initial fixed issue details",
					"cwe_id": 2,
					"description":"Initial fixed issue description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-8888-9999"}], "header": ["CVE"]}]
				}
			],
			"start_time":"2020-01-03 00:00:00",
			"end_time":"2020-01-03 01:00:00"
		}`,
		// Report that reopens the initial fixed finding via 'cross checktype'.
		`{
			"check_id":"00000000-0000-0000-0000-000000000005",
			"vulnerabilities": [
				{
					"summary":"Initial fixed issue",
					"score":6.0,
					"details":"Initial fixed issue details - modified",
					"cwe_id": 2,
					"description":"Initial fixed issue description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-9999-9999"}], "header": ["CVE"]}]
				}
			],
			"start_time":"2020-01-03 00:00:00",
			"end_time":"2020-01-03 01:00:00"
		}`,
		// Report that opens multiple new vulnerabilities.
		`{
			"check_id":"00000000-0000-0000-0000-000000000006",
			"vulnerabilities": [
				{
					"summary":"New issue one",
					"score":5.0,
					"details":"New issue one details",
					"cwe_id": 3,
					"description":"New issue one description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-0000-0001"}], "header": ["CVE"]}]
				},
				{
					"summary":"New issue two",
					"score":6.0,
					"details":"New issue two details",
					"cwe_id": 4,
					"description":"New issue two description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-0000-0002"}], "header": ["CVE"]}]
				}
			],
			"start_time":"2020-01-04 00:00:00",
			"end_time":"2020-01-04 01:00:00"
		}`,
		// Report that reopens the initially EXPIRED finding.
		`{
			"check_id":"00000000-0000-0000-0000-000000000007",
			"vulnerabilities": [
				{
					"summary":"Initial expired issue",
					"score":9.0,
					"details":"Initial expired issue details",
					"cwe_id": 2,
					"description":"Initial expired issue description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-1111-1111"}], "header": ["CVE"]}]
				}
			],
			"start_time":"2020-03-02 00:00:00",
			"end_time":"2020-03-02 01:00:00"
		}`,
		// Report that tries to reopen the initially FALSE_POSITIVE finding.
		`{
			"check_id":"00000000-0000-0000-0000-FFFFFFFFFFFF",
			"vulnerabilities": [
				{
					"summary":"Initial false positive issue",
					"score":9,
					"details":"Initial false positive issue details",
					"cwe_id": 2,
					"description":"Initial false positive description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-FFFF-FFFF"}], "header": ["CVE"]}]
				}
			],
			"start_time":"2020-01-02 00:00:00",
			"end_time":"2020-01-02 01:00:00"
		}`,
		// Report that fixes the initially FALSE_POSITIVE finding.
		`{
			"check_id":"00000000-0000-0000-0000-FFFFFFFFFFF0",
			"vulnerabilities": [],
			"start_time":"2020-01-03 00:00:00",
			"end_time":"2020-01-03 01:00:00"
		}`,
		// Report that tries to reopen the initially FALSE_POSITIVE finding - previously FIXED.
		`{
			"check_id":"00000000-0000-0000-0000-FFFFFFFFFFF2",
			"vulnerabilities": [
				{
					"summary":"Initial false positive issue",
					"score":9,
					"details":"Initial false positive issue details",
					"cwe_id": 2,
					"description":"Initial false positive description",
					"references":[],
					"resources":[{"name":"resource name", "rows": [{"CVE":"CVE-FFFF-FFFF"}], "header": ["CVE"]}]
				}
			],
			"start_time":"2020-01-03 00:00:00",
			"end_time":"2020-01-03 01:00:00"
		}`,
		// Report that fixes the initially FALSE_POSITIVE finding - previously FIXED.
		`{
			"check_id":"00000000-0000-0000-0000-FFFFFFFFFFF3",
			"vulnerabilities": [],
			"start_time":"2020-01-03 00:00:00",
			"end_time":"2020-01-03 01:00:00"
		}`,
		// Report that fixes the initially EXPIRED finding.
		`{
			"check_id":"00000000-0000-0000-0000-000000000008",
			"vulnerabilities": [],
			"start_time":"2020-03-01 00:00:00",
			"end_time":"2020-03-01 01:00:00"
		}`,
		// Processor Concurrency:
		// Report that adds new finding event to initial finding.
		`{
			"check_id":"10000000-0000-0000-0000-000000000001",
			"vulnerabilities": [
				{
					"summary":"Initial issue",
					"score":7.0,
					"details":"Initial issue details - concurrent",
					"cwe_id": 1,
					"description":"Initial issue description",
					"references":[],
					"resources":[]
				}
			],
			"start_time":"2020-01-02 00:00:00",
			"end_time":"2020-01-02 01:00:00"
		}`,
		// Processor Concurrency:
		// Report that fixes initial finding.
		`{
			"check_id":"10000000-0000-0000-0000-000000000002",
			"vulnerabilities": [],
			"start_time":"2020-01-03 00:00:00",
			"end_time":"2020-01-03 01:00:00"
		}`,
		// Processor Concurrency:
		// Report that reopens initial finding.
		`{
			"check_id":"10000000-0000-0000-0000-000000000003",
			"vulnerabilities": [
				{
					"summary":"Initial issue",
					"score":7.0,
					"details":"Initial issue details - concurrent",
					"cwe_id": 1,
					"description":"Initial issue description",
					"references":[],
					"resources":[]
				}
			],
			"start_time":"2020-01-04 00:00:00",
			"end_time":"2020-01-04 01:00:00"
		}`,
		// Processor Concurrency:
		// Report that adds new finding event to initial finding.
		`{
			"check_id":"10000000-0000-0000-0000-000000000004",
			"vulnerabilities": [
				{
					"summary":"Initial issue",
					"score":7.0,
					"details":"Initial issue details - concurrent",
					"cwe_id": 1,
					"description":"Initial issue description",
					"references":[],
					"resources":[]
				}
			],
			"start_time":"2020-01-05 00:00:00",
			"end_time":"2020-01-05 01:00:00"
		}`,
		// Processor Concurrency:
		// Report that fixes initial finding.
		`{
			"check_id":"10000000-0000-0000-0000-000000000005",
			"vulnerabilities": [],
			"start_time":"2020-01-06 00:00:00",
			"end_time":"2020-01-06 01:00:00"
		}`,
	}
)
