// +build integration

/*
Copyright 2020 Adevinta
*/

package test

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq" // postgres driver
)

var (
	dbPort = "5432" //default port, can be overriden by TEST_DB_PORT environment variable
)

const (
	// DB Conn. str template.
	dbConnStrFmt = "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s"

	// Test DB config.
	dbHost    = "127.0.0.1"
	dbUser    = "vulndb_test"
	dbPass    = "vulndb_test"
	dbName    = "vulndb_test"
	dbSSLMode = "disable"

	// Relative db dir path.
	dbDirPath = "../db"

	// Flyway commands.
	flywayClean   = "clean"
	flywayMigrate = "migrate"

	// Query statements.
	sourcesStmt    = "SELECT id as source_id, * FROM sources WHERE instance = :instance"
	targetsStmt    = "SELECT id as target_id, * FROM targets WHERE identifier = :identifier"
	issuesStmt     = "SELECT id as issue_id, * FROM issues WHERE summary = :summary AND description = :description"
	findingsStmt   = "SELECT id as finding_id, * FROM findings WHERE issue_id = :issue_id AND target_id = :target_id"
	fEventsStmt    = "SELECT * FROM finding_events WHERE finding_id = :finding_id AND time = :time"
	fExposuresStmt = "SELECT * FROM finding_exposures WHERE finding_id = :finding_id AND found_at = :found_at"
)

func init() {
	if envDBPort := os.Getenv("TEST_DB_PORT"); envDBPort != "" {
		dbPort = envDBPort
	}
}

// dbConnStr returns the connection
// str for postgres test db.
func dbConnStr() string {
	return fmt.Sprintf(dbConnStrFmt, dbHost, dbPort, dbUser, dbPass, dbName, dbSSLMode)
}

// db returns a new sqlx DB.
func db() (*sqlx.DB, error) {
	return sqlx.Connect("postgres", dbConnStr())
}

// resetDB cleans the current vulndb database
// in the test postgres container and loads the
// initial schema again.
func resetDB() error {
	err := runFlywayCmd(dbDirPath, flywayClean)
	if err != nil {
		return err
	}
	return runFlywayCmd(dbDirPath, flywayMigrate)
}

// runFlywayCmd runs the specified flyway cmd against the
// test postgres container.
func runFlywayCmd(dbDirPath, flywayCommand string) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}
	dir := path.Join(wd, dbDirPath)

	cmdName := "docker"
	cmdArgs := []string{
		"run",
		"--net=host",
		"-v",
		dir + ":/scripts",
		"boxfuse/flyway",
		"-user=" + dbUser,
		"-password=" + dbPass,
		"-url=jdbc:postgresql://" + dbHost + ":" + dbPort + "/" + dbName,
		"-baselineOnMigrate=true",
		"-locations=filesystem:/scripts/",
		flywayCommand,
	}

	cmd := exec.Command(cmdName, cmdArgs...)
	cmd.Env = os.Environ()
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("Error executing flyway command, command output:\n%s.\n Error:\n %s", output, err)
	}
	return nil
}

// fetchData retrieves data from test db.
// Because DB IDs are autogenerated, we can not query by them,
// so we have to retrieve data based on other attributes.
// E.g.: Issue{summary, description}, target{identifier}, etc.
func fetchDBData(table string, args map[string]interface{}, db *sqlx.DB) (map[string]interface{}, error) {
	var stmt string

	switch table {
	case sourcesTable:
		stmt = sourcesStmt
	case targetsTable:
		stmt = targetsStmt
	case issuesTable:
		stmt = issuesStmt
	case findingsTable:
		stmt = findingsStmt
	case fEventsTable:
		stmt = fEventsStmt
	case fExposuresTable:
		stmt = fExposuresStmt
	}

	if stmt == "" {
		return nil, errors.New("Table not supported")
	}

	nstmt, err := db.PrepareNamed(stmt)
	rows, err := nstmt.Queryx(args)
	if err != nil {
		return nil, err
	}

	data := make(map[string]interface{})
	if rows.Next() {
		if err = rows.MapScan(data); err != nil {
			return nil, err
		}
	}

	if rows.Next() {
		return nil, errors.New("Multiple results")
	}

	return data, nil
}
